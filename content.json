{"meta":{"title":"Hexo","subtitle":"","description":"","author":"coder-xbai","url":"https://coder-xbai.github.io","root":"/"},"pages":[{"title":"about","date":"2023-06-16T06:25:55.000Z","updated":"2023-06-16T06:26:18.369Z","comments":true,"path":"about/index.html","permalink":"https://coder-xbai.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-06-16T06:19:23.000Z","updated":"2023-06-16T06:20:30.738Z","comments":true,"path":"tags/index.html","permalink":"https://coder-xbai.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-06-16T06:21:01.000Z","updated":"2023-06-16T06:22:46.637Z","comments":true,"path":"categories/index.html","permalink":"https://coder-xbai.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql_1","slug":"mysql-1","date":"2023-06-27T02:25:15.000Z","updated":"2023-06-27T13:53:47.096Z","comments":true,"path":"2023/06/27/mysql-1.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/27/mysql-1.html","excerpt":"","text":"MySql初级查漏补缺1，支持的json类型​ 从mysql5.7开始支持，到8.x版本时JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使用更方便。 123456789101112131415161718CREATE DATABASE IF NOT EXISTS test01_office CHARACTER SET &#x27;utf8&#x27;;USE test01_officeCREATE TABLE test_json(js json);-- json 类型 &#x27;&#123;&quot;KEY1&quot;:&quot;value1&quot;,&quot;KEY2&quot;:&quot;value2&quot; &#125;&#x27;INSERT INTO test_json (js)VALUES ( &#x27;&#123;&quot;KEY&quot;:&quot;value&quot;,&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;)SELECT * FROM test_json; 2，使用时间类型选择​ 在多数开发过程中，都是选择 DATETIME 类型，包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。 但是如果是记录注册时间或商品发布时间等。使用_TIMESTAMP(时间戳)更方便计算。 3，主键自增一个小知识 —自增变量的持久化​ 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 ​ 从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。 删除id为5的记录，结果如下： ​ 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。 ​ 在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： 从结果可以看出，自增变量已经持久化了。 ​ MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。 4，存储过程创建存储过程格式12345CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END ​ 说明：INOUT ：当前参数既可以为输入参数，也可以为输出参数。 ​ 类似于Java中的方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123;方法体;&#125; ​ 例子: 123456789DELIMITER //CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGINSELECT COUNT(*) INTO num FROM fruitsWHERE s_id = sid;END //DELIMITER ; 调用存储过程及查看返回结果123456mysql&gt; CALL CountProc (101, @num);Query OK, 1 row affected (0.00 sec)-- 查看返回结果mysql&gt; SELECT @num; 5，变量、流程控制与游标的重要知识变量​ 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。 1234567#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;或SHOW VARIABLES; ​ 用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。 ​ 会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。​ 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。 1234567#方式1：“=”或“:=”SET @用户变量 = 值;SET @用户变量 := 值;#方式2：“:=” 或 INTO关键字SELECT @用户变量 := 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句]; 查看用户变量的值 （查看、比较、运算等） 1234567SELECT @用户变量SELECT @a;SELECT @num := COUNT(*) FROM employees;SELECT @num;SELECT AVG(salary) INTO @avgsalary FROM employees;SELECT @avgsalary;SELECT @big; #查看某个未声明的变量时，将得到NULL值 局部变量 123DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULLDECLARE myparam INT DEFAULT 100; 6，流程控制分支12345IF 表达式1 THEN 操作1[ELSEIF 表达式2 THEN 操作2]……[ELSE 操作N]END IF 例子：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。 1234567891011DELIMITER //CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_yearFROM employees WHERE employee_id = emp_id;IF emp_salary &lt; 8000 AND hire_year &gt; 5THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;END IF;END //DELIMITER ; 分支结构之 CASE1234567#情况一：类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要） 例3：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。 12345678910111213141516DELIMITER //BEGINDECLARE emp_sal DOUBLE;DECLARE bonus DECIMAL(3,2);SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;CASEWHEN emp_sal&lt;9000THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;WHEN emp_sal&lt;10000 AND bonus IS NULLTHEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;ELSEUPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;END CASE;END //DELIMITER ; 循环结构之LOOP使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。 1234567DECLARE id INT DEFAULT 0;add_loop:LOOPSET id = id +1;IF id &gt;= 10 THEN LEAVE add_loop;END IF;END LOOP add_loop; 循环结构之WHILE和REPEATWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下： 例子：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。 123456789101112131415DELIMITER //CREATE PROCEDURE update_salary_while(OUT num INT)BEGINDECLARE avg_sal DOUBLE ;DECLARE while_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_sal FROM employees;WHILE avg_sal &gt; 5000 DOUPDATE employees SET salary = salary * 0.9;SET while_count = while_count + 1;SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;SET num = while_count;END //DELIMITER ; REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。 1234567891011DELIMITER //CREATE PROCEDURE test_repeat()BEGINDECLARE i INT DEFAULT 0;REPEATSET i = i + 1;UNTIL i &gt;= 10END REPEAT;SELECT i;END //DELIMITER ; 跳转语句之LEAVE语句 (类似于 java中的break)，跳转语句之ITERATE语句（类似于 java中的continue） 具体解释省略 7，游标​ 定义：在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。 游标的使用过程： 第一步，声明游标()； 1DECLARE cur_emp CURSOR FOR 第二步，打开游标(OPEN cursor_name)； 1OPEN cursor_name 第三步使用游标（从游标中取得数据）()； 1FETCH cursor_name INTO var_name [, var_name] ... 第四步，关闭游标 1CLOSE cursor_name ​ 例子：创建存储过程“get_count_by_limit_total_salary()”，声明IN参limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。 123456789101112131415161718192021222324DELIMITER //CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUTtotal_count INT)BEGINDECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值DECLARE emp_count INT DEFAULT 0; #记录循环个数#定义游标DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;#打开游标OPEN emp_cursor;REPEAT#使用游标（从游标中获取数据）FETCH emp_cursor INTO cursor_salary;SET sum_salary = sum_salary + cursor_salary;SET emp_count = emp_count + 1;UNTIL sum_salary &gt;= limit_total_salaryEND REPEAT;SET total_count = emp_count;#关闭游标CLOSE emp_cursor;END //DELIMITER ; 8，触发器​ 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。 语法结构 12345CREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名FOR EACH ROW触发器执行的语句块; 例子：创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。 12345678910DELIMITER //CREATE TRIGGER before_insertBEFORE INSERT ON test_triggerFOR EACH ROWBEGININSERT INTO test_trigger_log (t_log)VALUES(&#x27;before_insert&#x27;);END //DELIMITER ; 查看、删除触发器 12345SHOW TRIGGERS\\GSHOW CREATE TRIGGER 触发器名SELECT * FROM information_schema.TRIGGERS;DROP TRIGGER IF EXISTS 触发器名称;","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MySql初级查漏补缺","slug":"MySql初级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E5%88%9D%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"SparseArray","slug":"SparseArray","date":"2023-06-18T07:29:49.000Z","updated":"2023-06-27T02:59:48.429Z","comments":true,"path":"2023/06/18/SparseArray.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/18/SparseArray.html","excerpt":"","text":"稀疏矩阵的原理及java实现原理 如上图，在一个11X11的二维数组中，其实只有几个有效数字，如果全部存储，会造成空间上的浪费，使用3X3的稀疏数组存储有效值，会节约大量空间。 其中稀疏数组的 row[0][0] ：原始二维数组的行 数；row[0][1]：原始二维数组的列数；row[0][2]：原始二维数组有效值的个数。稀疏数组从第二行开始：row[1][0]代表原始二维数组第一个有效值所在的行索引 ；row[1][0]：原始二维数组第一个有效值所在的列索引；row[1][2]：原始二维数组第一个有效值 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @author: zsf * @date: 2023/6/18 9:56 * @description: */public class SparseArray &#123; public static void main(String[] args) throws IOException &#123;// 创建一个原始的二维数组 11*11// 0表示无棋子 1：黑子 2：白子 int chesssArr1[][] = new int[11][11];// 给有棋子的位置赋值 chesssArr1[1][2] = 1; chesssArr1[2][3] = 2; System.out.println(&quot;原始二维数组：&quot;); for (int[] row : chesssArr1) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; /* * 将二维转换为稀疏数组 * 1 遍历二维数组 得到非0数据的个数 * */ int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125;// 2 创建对应的稀疏数组 int sparseArry[][] = new int[sum + 1][3]; //第二行开始记录值// 3 给稀疏数组第一行赋值 sparseArry[0][0] = 11; sparseArry[0][1] = 11; sparseArry[0][2] = sum;// 4 ,遍历二维数组 ，将非0的数放入稀疏数组 int count = 0; //用于记录第几个非0的数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; count++; //从第二行稀疏数组开始记录非0值所在的行与列 sparseArry[count][0] = i; //行的位置 sparseArry[count][1] = j;//列的位置 sparseArry[count][2] = chesssArr1[i][j];//值 &#125; &#125; &#125;// 5 输出稀疏数组 System.out.println(&quot;得到的稀疏的数组：&quot;); for (int i = 0; i &lt; sparseArry.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, sparseArry[i][0], sparseArry[i][1], sparseArry[i][2]); &#125; System.out.println();// 将稀疏数组还原成原始二维数组// 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]// 2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可. int chesssArr2[][] = new int[sparseArry[0][0]][sparseArry[0][1]]; for (int i = 1; i &lt; sparseArry.length; i++) &#123; chesssArr2[sparseArry[i][0]][sparseArry[i][1]] = sparseArry[i][2]; &#125; System.out.println(&quot;恢复后的二维数组&quot;); for (int[] row : chesssArr2) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; SparseArray a = new SparseArray();// a.save_sparseArray(sparseArry,&quot;src\\\\com\\\\zsf\\\\day01\\\\sparse.txt&quot;); int[][] load_sparseArray = a.load_sparseArray(&quot;src\\\\com\\\\\\\\zsf\\\\day01\\\\sparse.txt&quot;); System.out.println(&quot;读入的稀疏矩阵为~~~~~~~~&quot;); for (int i = 0; i &lt; load_sparseArray.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, load_sparseArray[i][0], load_sparseArray[i][1], load_sparseArray[i][2]); &#125; &#125;&#125; 稀疏数组的保存与加载1234567891011121314151617181920 public int[][] save_sparseArray(int sparseArry[][], String file_path) throws IOException &#123; // 将稀疏数组保存下来 &quot;./sparse.txt&quot;; String save_dir = file_path; File file = new File(save_dir); if (!file.exists()) &#123; file.createNewFile(); FileWriter fileWriter = new FileWriter(save_dir); for (int i = 0; i &lt; sparseArry.length; i++) &#123; for (int j = 0; j &lt; sparseArry[i].length; j++) &#123; fileWriter.write(sparseArry[i][j] + &quot;\\t&quot;); &#125;// 一行输出完后添加换行符 fileWriter.write(&quot;\\r\\n&quot;); &#125; fileWriter.close(); System.out.println(&quot;保存成功&quot;); &#125;// 加载 return null; &#125; 1234567891011121314151617181920212223 public int[][] load_sparseArray(String file_path) throws IOException &#123; File file = new File(file_path); BufferedReader in = new BufferedReader(new FileReader(file)); String line; int row = 0; String[] tem;// 在使用一次in.lines/readline后，文件指针指向文件末尾，即都是0// long num_row = in.lines().count(); int sparseArry[][] = new int[3][3]; int count = 0;// 1 要确定文件中稀疏数组有多少行 while ((line = in.readLine()) != null) &#123;// line 接收了每一行的 字符 ,即稀疏数组的 行数 tem = line.split(&quot;\\t&quot;); System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, Integer.parseInt(tem[0]), Integer.parseInt(tem[1]), Integer.parseInt(tem[2])); sparseArry[count][0] = Integer.parseInt(tem[0]); //行的位置 sparseArry[count][1] = Integer.parseInt(tem[1]);//列的位置 sparseArry[count][2] = Integer.parseInt(tem[2]);//值 count++; &#125; return sparseArry; &#125; 实现效果 容易踩坑的点 使用 BufferedReader 的api 时要注意，你只要调用过一次 in.read或in.read()文件指针指向文件末尾，即都是0 时时记住模块化开发，提高程序的复用性","categories":[{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"}],"tags":[{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"}]},{"title":"MongoDB数据库","slug":"MongDB","date":"2023-02-01T02:39:11.000Z","updated":"2023-06-16T05:49:51.299Z","comments":true,"path":"2023/02/01/MongDB.html","link":"","permalink":"https://coder-xbai.github.io/2023/02/01/MongDB.html","excerpt":"","text":"MongoDB数据库是以集合为单位的 use 数据库 不是集合 mongodb插入数据 db.collection.insert({}） 插入数据，id存在就出错 dbcollection.save({}) 插入数据，_id存在就修改，_id不存在就添加 ###修改数据 db.集合名称。update（,,{multi:}) db.collection.update({“name”:”hr”},{“name”:”mnc”}) 更新一条，根据键值对更新 db.collection.update({“name”:”hr”},{$set:{“name”:”mnc”}}） 更新一条 db.collection.update({},$set:{“gender”:0},{multi:true}) muiti参数默认为false时，只更新一条数据，为true时，更新全部数据 ###删除数据库 db.dropDatabase(){ “dropped” : “runoob”, “ok” : 1 }###删除集合 db.collection.drop()###删除数据 -db.collection.remove({“age”:”22”},{justone:true}) justone 默认为false，即删除全部指定条件的数据。为false时，只删除一条数据 条件查询 db.collection.find({“age”:”22”}) 通过某条数据中的片段（键值对）来进行限定查询，这是一个多行查询 db.collection.findOne({“age”:”22”}) 只查询符合条件的一条数据 db.collection.find({“age”:”22”}).pretty() 格式化输出查询结果 ####比较运算符 等于： ： 小于： $lt(less than) 小于等于： $lte(less than equal) 大于： $gt(greater than) 大于等于： $gte(greater than equal) 不等于： $ne 范围： $in db.collection.find({“age”:{$lt:18}}) 查询年龄小于18的所有的数据 db.collection.find({age:{$in:[18,28,38]}}) 查询年龄18，28，38 的数据 db.collection.find（{“age”:”18”,”addr”:”上海”}）多字段查询 逻辑运算符 and :在json中写多个条件即可 $or :值为数组，数组中每个元素为json 123db.test1000.find(&#123;$or:[&#123;age:12&#125;,&#123;&quot;name&quot;:&quot;xiaohong&quot;&#125;]&#125;) # $or:[&#123;键值对&#125;，键值对] $nor: （既不也不） db.collection1.find({$nor:[{name:”xiaomu”},{name:”xiaoli”}]}) 查询姓名不为xiaomu,xiaoli的全部数据 不在范围： $nin:[] 正则表达式db.collection.find({name:/^abc/}) #name 字段中包含abc的所欲数据 12db.test1000.find(&#123;name:&#123;$regex:&quot;hong&quot;&#125;&#125;) #包含hong这个字段的数据 1db.test1000.find(&#123;name:&#123;$regex:&quot;hong$&quot;&#125;&#125;) #以hong结尾的字段的数据 ###分页： db.collection1.find().skip(0).limit(10) ;//查询从0条开始，查询10条，skip()方法默认参数为 0 ，表示跳过的条数 （当数据量大的时候，先skip再limit） ###自定义查询 db.test1000.find({$where:function(){return this.age&gt;18;}}) 查询年龄大于18的数据 ###投影查询 db.collection.find({},_id:0,name:1) 参数为1表示显示，参数为0为不显示，如果不显示字段，要明确设置为0 ###排序 db.collection1.find().sort({age:1});//按照年龄升序排序，为-1的话表示降序排序 ###存在 db.c2.find({hight:{$exists:1}})；//查询存在hight字段的数据 ###查看数据总条数 db.collection1.count();//统计集合collection1中的数据数量 db.collection1.find({条件}).count();//统计集合collection1中的数据数量 #消除重复 db.collection.distinct({}) ##数据备份与恢复 备份：mongodump -h dbhost -d dbname -o dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test -o：需要备份的数据存放的位置，例如：d:\\data (如果没有则自动创建) 恢复：mongorestore -h dbhost -d dbname -directoryperdb dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test，此名称也可以和备份的时候不一样 -directoryperdb ：备份数据所在的位置，例如：d:\\data注意：恢复时要在退出mongo命令行状态下执行 ###导入和导出 导出：mongoexport -h dbhost -d dbname -c collectionName -o output -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 -o：指明要导出的文件路径加文件名，文件名可以是txt、word、excel等多种文件格式 -导入：mongoimport -h dbhost -d dbname -c collectionname 文件的地址路径 -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 注意：导入时要在退出mongo命令行状态下执行，导入导出与数据备份和恢复相似 mongodb聚合命令12345678db.collection.aggregate(&#123; $group:&#123; _id:&quot;$gender&quot;, #_id:(可以是多个参数，后续调用时，用.对象名的方法) counter:&#123;$sum:1&#125; &#125;&#125;) 其中还有 $match(匹配到适合条件的数据) $project：(投影显示)修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $min,max,sun,avg,first,last 等 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。（有一个保留空值和空列表的参数：perserve….） $sort:将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 爬虫数据去重（增量式爬虫） 使用数据可建立关键字段的唯一索引进行去重 联合索引（通过多个字段来确定数据的唯一性） url地址去重 url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况 url存在redis中 拿到url地址，判断url在redis的集合中是否存在 存在：说明url已经被请求过，不再请求 不存在：url没有被请求过，请求，把该url存入redis的集合中 ####布隆过滤器 （redis） 使用加密算法加密url地址，得到多个值， 往对应值的位置把结果设置为1 新来一个url地址，一样通过加密算法生成多个值 如果对应位置的值全为1，说明这个url地址已经请求过 否则没有请求过，请求后，就把对应位置的值设置为1 根据数据本身去重 选择特定的字段，使用加密算法（MD5，sha1）将字段进行加密，生成字符串，存入redis的集合中 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}],"categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"},{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"}],"tags":[{"name":"MySql初级查漏补缺","slug":"MySql初级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E5%88%9D%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}