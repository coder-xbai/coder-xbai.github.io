{"meta":{"title":"Hexo","subtitle":"","description":"","author":"coder-xbai","url":"https://coder-xbai.github.io","root":"/"},"pages":[{"title":"about","date":"2023-06-16T06:25:55.000Z","updated":"2023-06-16T06:26:18.369Z","comments":true,"path":"about/index.html","permalink":"https://coder-xbai.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-06-16T06:21:01.000Z","updated":"2023-06-16T06:22:46.637Z","comments":true,"path":"categories/index.html","permalink":"https://coder-xbai.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-06-16T06:19:23.000Z","updated":"2023-06-16T06:20:30.738Z","comments":true,"path":"tags/index.html","permalink":"https://coder-xbai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SparseArray","slug":"SparseArray","date":"2023-06-18T07:29:49.000Z","updated":"2023-06-18T08:20:50.099Z","comments":true,"path":"2023/06/18/SparseArray.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/18/SparseArray.html","excerpt":"","text":"稀疏矩阵的原理及java实现原理 如上图，在一个11X11的二维数组中，其实只有几个有效数字，如果全部存储，会造成空间上的浪费，使用3X3的稀疏数组存储有效值，会节约大量空间。 其中稀疏数组的 row[0][0] ：原始二维数组的行 数；row[0][1]：原始二维数组的列数；row[0][2]：原始二维数组有效值的个数。稀疏数组从第二行开始：row[1][0]代表原始二维数组第一个有效值所在的行索引 ；row[1][0]：原始二维数组第一个有效值所在的列索引；row[1][2]：原始二维数组第一个有效值 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @author: zsf * @date: 2023/6/18 9:56 * @description: */public class SparseArray &#123; public static void main(String[] args) throws IOException &#123;// 创建一个原始的二维数组 11*11// 0表示无棋子 1：黑子 2：白子 int chesssArr1[][] = new int[11][11];// 给有棋子的位置赋值 chesssArr1[1][2] = 1; chesssArr1[2][3] = 2; System.out.println(&quot;原始二维数组：&quot;); for (int[] row : chesssArr1) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; /* * 将二维转换为稀疏数组 * 1 遍历二维数组 得到非0数据的个数 * */ int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125;// 2 创建对应的稀疏数组 int sparseArry[][] = new int[sum + 1][3]; //第二行开始记录值// 3 给稀疏数组第一行赋值 sparseArry[0][0] = 11; sparseArry[0][1] = 11; sparseArry[0][2] = sum;// 4 ,遍历二维数组 ，将非0的数放入稀疏数组 int count = 0; //用于记录第几个非0的数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; count++; //从第二行稀疏数组开始记录非0值所在的行与列 sparseArry[count][0] = i; //行的位置 sparseArry[count][1] = j;//列的位置 sparseArry[count][2] = chesssArr1[i][j];//值 &#125; &#125; &#125;// 5 输出稀疏数组 System.out.println(&quot;得到的稀疏的数组：&quot;); for (int i = 0; i &lt; sparseArry.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, sparseArry[i][0], sparseArry[i][1], sparseArry[i][2]); &#125; System.out.println();// 将稀疏数组还原成原始二维数组// 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]// 2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可. int chesssArr2[][] = new int[sparseArry[0][0]][sparseArry[0][1]]; for (int i = 1; i &lt; sparseArry.length; i++) &#123; chesssArr2[sparseArry[i][0]][sparseArry[i][1]] = sparseArry[i][2]; &#125; System.out.println(&quot;恢复后的二维数组&quot;); for (int[] row : chesssArr2) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; SparseArray a = new SparseArray();// a.save_sparseArray(sparseArry,&quot;src\\\\com\\\\zsf\\\\day01\\\\sparse.txt&quot;); int[][] load_sparseArray = a.load_sparseArray(&quot;src\\\\com\\\\\\\\zsf\\\\day01\\\\sparse.txt&quot;); System.out.println(&quot;读入的稀疏矩阵为~~~~~~~~&quot;); for (int i = 0; i &lt; load_sparseArray.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, load_sparseArray[i][0], load_sparseArray[i][1], load_sparseArray[i][2]); &#125; &#125;&#125; 稀疏数组的保存与加载1234567891011121314151617181920 public int[][] save_sparseArray(int sparseArry[][], String file_path) throws IOException &#123; // 将稀疏数组保存下来 &quot;./sparse.txt&quot;; String save_dir = file_path; File file = new File(save_dir); if (!file.exists()) &#123; file.createNewFile(); FileWriter fileWriter = new FileWriter(save_dir); for (int i = 0; i &lt; sparseArry.length; i++) &#123; for (int j = 0; j &lt; sparseArry[i].length; j++) &#123; fileWriter.write(sparseArry[i][j] + &quot;\\t&quot;); &#125;// 一行输出完后添加换行符 fileWriter.write(&quot;\\r\\n&quot;); &#125; fileWriter.close(); System.out.println(&quot;保存成功&quot;); &#125;// 加载 return null; &#125; 1234567891011121314151617181920212223 public int[][] load_sparseArray(String file_path) throws IOException &#123; File file = new File(file_path); BufferedReader in = new BufferedReader(new FileReader(file)); String line; int row = 0; String[] tem;// 在使用一次in.lines/readline后，文件指针指向文件末尾，即都是0// long num_row = in.lines().count(); int sparseArry[][] = new int[3][3]; int count = 0;// 1 要确定文件中稀疏数组有多少行 while ((line = in.readLine()) != null) &#123;// line 接收了每一行的 字符 ,即稀疏数组的 行数 tem = line.split(&quot;\\t&quot;); System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, Integer.parseInt(tem[0]), Integer.parseInt(tem[1]), Integer.parseInt(tem[2])); sparseArry[count][0] = Integer.parseInt(tem[0]); //行的位置 sparseArry[count][1] = Integer.parseInt(tem[1]);//列的位置 sparseArry[count][2] = Integer.parseInt(tem[2]);//值 count++; &#125; return sparseArry; &#125; 实现效果 容易踩坑的点 使用 BufferedReader 的api 时要注意，你只要调用过一次 in.read或in.read()文件指针指向文件末尾，即都是0 时时记住模块化开发，提高程序的复用性","categories":[{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"}],"tags":[{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"}]},{"title":"MongoDB数据库","slug":"MongDB","date":"2023-02-01T02:39:11.000Z","updated":"2023-06-16T05:49:51.299Z","comments":true,"path":"2023/02/01/MongDB.html","link":"","permalink":"https://coder-xbai.github.io/2023/02/01/MongDB.html","excerpt":"","text":"MongoDB数据库是以集合为单位的 use 数据库 不是集合 mongodb插入数据 db.collection.insert({}） 插入数据，id存在就出错 dbcollection.save({}) 插入数据，_id存在就修改，_id不存在就添加 ###修改数据 db.集合名称。update（,,{multi:}) db.collection.update({“name”:”hr”},{“name”:”mnc”}) 更新一条，根据键值对更新 db.collection.update({“name”:”hr”},{$set:{“name”:”mnc”}}） 更新一条 db.collection.update({},$set:{“gender”:0},{multi:true}) muiti参数默认为false时，只更新一条数据，为true时，更新全部数据 ###删除数据库 db.dropDatabase(){ “dropped” : “runoob”, “ok” : 1 }###删除集合 db.collection.drop()###删除数据 -db.collection.remove({“age”:”22”},{justone:true}) justone 默认为false，即删除全部指定条件的数据。为false时，只删除一条数据 条件查询 db.collection.find({“age”:”22”}) 通过某条数据中的片段（键值对）来进行限定查询，这是一个多行查询 db.collection.findOne({“age”:”22”}) 只查询符合条件的一条数据 db.collection.find({“age”:”22”}).pretty() 格式化输出查询结果 ####比较运算符 等于： ： 小于： $lt(less than) 小于等于： $lte(less than equal) 大于： $gt(greater than) 大于等于： $gte(greater than equal) 不等于： $ne 范围： $in db.collection.find({“age”:{$lt:18}}) 查询年龄小于18的所有的数据 db.collection.find({age:{$in:[18,28,38]}}) 查询年龄18，28，38 的数据 db.collection.find（{“age”:”18”,”addr”:”上海”}）多字段查询 逻辑运算符 and :在json中写多个条件即可 $or :值为数组，数组中每个元素为json 123db.test1000.find(&#123;$or:[&#123;age:12&#125;,&#123;&quot;name&quot;:&quot;xiaohong&quot;&#125;]&#125;) # $or:[&#123;键值对&#125;，键值对] $nor: （既不也不） db.collection1.find({$nor:[{name:”xiaomu”},{name:”xiaoli”}]}) 查询姓名不为xiaomu,xiaoli的全部数据 不在范围： $nin:[] 正则表达式db.collection.find({name:/^abc/}) #name 字段中包含abc的所欲数据 12db.test1000.find(&#123;name:&#123;$regex:&quot;hong&quot;&#125;&#125;) #包含hong这个字段的数据 1db.test1000.find(&#123;name:&#123;$regex:&quot;hong$&quot;&#125;&#125;) #以hong结尾的字段的数据 ###分页： db.collection1.find().skip(0).limit(10) ;//查询从0条开始，查询10条，skip()方法默认参数为 0 ，表示跳过的条数 （当数据量大的时候，先skip再limit） ###自定义查询 db.test1000.find({$where:function(){return this.age&gt;18;}}) 查询年龄大于18的数据 ###投影查询 db.collection.find({},_id:0,name:1) 参数为1表示显示，参数为0为不显示，如果不显示字段，要明确设置为0 ###排序 db.collection1.find().sort({age:1});//按照年龄升序排序，为-1的话表示降序排序 ###存在 db.c2.find({hight:{$exists:1}})；//查询存在hight字段的数据 ###查看数据总条数 db.collection1.count();//统计集合collection1中的数据数量 db.collection1.find({条件}).count();//统计集合collection1中的数据数量 #消除重复 db.collection.distinct({}) ##数据备份与恢复 备份：mongodump -h dbhost -d dbname -o dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test -o：需要备份的数据存放的位置，例如：d:\\data (如果没有则自动创建) 恢复：mongorestore -h dbhost -d dbname -directoryperdb dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test，此名称也可以和备份的时候不一样 -directoryperdb ：备份数据所在的位置，例如：d:\\data注意：恢复时要在退出mongo命令行状态下执行 ###导入和导出 导出：mongoexport -h dbhost -d dbname -c collectionName -o output -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 -o：指明要导出的文件路径加文件名，文件名可以是txt、word、excel等多种文件格式 -导入：mongoimport -h dbhost -d dbname -c collectionname 文件的地址路径 -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 注意：导入时要在退出mongo命令行状态下执行，导入导出与数据备份和恢复相似 mongodb聚合命令12345678db.collection.aggregate(&#123; $group:&#123; _id:&quot;$gender&quot;, #_id:(可以是多个参数，后续调用时，用.对象名的方法) counter:&#123;$sum:1&#125; &#125;&#125;) 其中还有 $match(匹配到适合条件的数据) $project：(投影显示)修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $min,max,sun,avg,first,last 等 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。（有一个保留空值和空列表的参数：perserve….） $sort:将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 爬虫数据去重（增量式爬虫） 使用数据可建立关键字段的唯一索引进行去重 联合索引（通过多个字段来确定数据的唯一性） url地址去重 url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况 url存在redis中 拿到url地址，判断url在redis的集合中是否存在 存在：说明url已经被请求过，不再请求 不存在：url没有被请求过，请求，把该url存入redis的集合中 ####布隆过滤器 （redis） 使用加密算法加密url地址，得到多个值， 往对应值的位置把结果设置为1 新来一个url地址，一样通过加密算法生成多个值 如果对应位置的值全为1，说明这个url地址已经请求过 否则没有请求过，请求后，就把对应位置的值设置为1 根据数据本身去重 选择特定的字段，使用加密算法（MD5，sha1）将字段进行加密，生成字符串，存入redis的集合中 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}],"categories":[{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"},{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}