{"meta":{"title":"Hexo","subtitle":"","description":"","author":"coder-xbai","url":"https://coder-xbai.github.io","root":"/"},"pages":[{"title":"about","date":"2023-06-16T06:25:55.000Z","updated":"2023-06-16T06:26:18.369Z","comments":true,"path":"about/index.html","permalink":"https://coder-xbai.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-06-16T06:21:01.000Z","updated":"2023-06-16T06:22:46.637Z","comments":true,"path":"categories/index.html","permalink":"https://coder-xbai.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-06-16T06:19:23.000Z","updated":"2023-06-16T06:20:30.738Z","comments":true,"path":"tags/index.html","permalink":"https://coder-xbai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bolg_test","slug":"bolg-test","date":"2024-05-16T06:20:14.000Z","updated":"2024-05-16T06:21:14.693Z","comments":true,"path":"2024/05/16/bolg-test.html","link":"","permalink":"https://coder-xbai.github.io/2024/05/16/bolg-test.html","excerpt":"","text":"这是一个GitHub测试博客，今天是2024年5月16日","categories":[{"name":"test","slug":"test","permalink":"https://coder-xbai.github.io/categories/test/"}],"tags":[]},{"title":"ruoyi-back-1","slug":"ruoyi-back-1","date":"2023-10-08T03:11:46.000Z","updated":"2023-10-17T08:20:08.436Z","comments":true,"path":"2023/10/08/ruoyi-back-1.html","link":"","permalink":"https://coder-xbai.github.io/2023/10/08/ruoyi-back-1.html","excerpt":"","text":"若依后端学习总结1，数据库部分（数据表结构总结）部门树型结构这里是根据dept_id，parent_id（父级级部门）来进行区分父子部门，在后端查询某个部门的所有部门及其子部门是通过查询（ancestors）字段 其中每个用户还有对应的职位。 角色权限管理使用三张基本表，2张关联表实现简单的。 其中每个角色都有一个role_key 每个用户都有至少一个角色，user_id对应一个role_id，而每个角色有对应菜单，role_id对应一个menu_id。同理，一个role_id对应dept_id 后端调用逻辑(简单版)：用户发起登录后，根据用户id，查询对应角色以及角色对应的部门（这部分需要联表查询），然后返回一个JSON 。","categories":[{"name":"若依框架学习","slug":"若依框架学习","permalink":"https://coder-xbai.github.io/categories/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ruoyi_1","slug":"ruoyi-1","permalink":"https://coder-xbai.github.io/tags/ruoyi-1/"}]},{"title":"背诵笔记","slug":"面试背诵笔记","date":"2023-09-27T02:25:15.000Z","updated":"2023-11-01T14:12:06.426Z","comments":true,"path":"2023/09/27/面试背诵笔记.html","link":"","permalink":"https://coder-xbai.github.io/2023/09/27/%E9%9D%A2%E8%AF%95%E8%83%8C%E8%AF%B5%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"java背诵笔记1，计算机网络部分基本概念网络地址：网络地址（Network address）由ip和子网掩码按位与得出，只有网络地址相同的ip才在同一子网内网络地址是子网中最小的地址计算方式：网络地址 = IP &amp; 子网掩码广播地址：广播地址（Broadcast Address）是专门用于同时向网络中所有工作站进行发送的一个地址广播地址是该子网主机地址全1的地址，即子网中最大的地址 计算方式：广播地址 = (~子网掩码) | 网络地址 子网掩码子网掩码 （Subnet mask）是一个32位的2进制数 ，它必须结合IP地址一起使用。 子网掩码只有一个作用，就是将某个IP地址划分成“网络地址”和“主机地址”两部分。 缩写有时候我们会看到192.168.1.123/24这样的表示方法，其中/24就是子网掩码255.255.255.0的缩写 计算方式：二进制子网掩码中1的个数 子网容量计算子网数根据子网掩码可划分的最大子网数 计算方式：子网数 = 2^(实际子网掩码缩写 - 相应网络类型默认子网掩码缩写) 最大主机数计算方式：最大主机数 = 2^(主机地址的位数) 可用主机数计算方式：可用主机数 = 最大主机数 - 2 因为一个子网中主机号全为0的是网络地址，全为1的是广播地址，所以要 -2 1，Q:cookie，session与token的区别 A: Cookies是由服务器产生的,当浏览器第一次访问服务端为标记用户所设置独特的身份标识数据。格式为key=value，根据cookie中的值识别用户身份并传值 Session机制是一种服务端的机制 ，服务器使用一种类似散列表的结构来保存信息。server 会为用户生成一个 session，为其分配唯一的 sessionId，通过 cookie 传给浏览器。 区别： cookie 和session的区别 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用cookie。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 Token是在服务端将用户信息经过Base64Url编码过后传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了，这个方法叫做JWT(JSON Web Token)。 Token类似一个令牌，无状态的，服务端所需的信息被Base64编码后放到Token中，服务器可以直接解码出其中的数据。 Token相比较于Session的优点在于，当后端系统有多台时，由于是客户端访问时直接带着数据，因此无需做共享数据的操作。 2，Q：网络的七层架构,tcp/ip在那一层A: 计算机网络常见网络结构 其中传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。 Q: TCP与UDP的区别 A: 1） TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低2） 由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全3） 在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小4） 每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信 Q: TCP 三次握手/四次挥手A: TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。 三次握手： 第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器，主机 B由 SYN=1 知道，A 要求建立联机；第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的seq+1),syn=1,ack=1,随机产生 seq=7654321 的包第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认eq 值与 ack=1 则连接建立成功。 四次挥手：TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。 1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 Q: 从浏览器地址栏输入 url 到显示主页的过程A: 2，JAVA基础部分Q: HashMap和Hashtable的区别A: HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。 HashMap线程不安全，没有synchronized；HashTable线程安全 Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 HashMap允许key和value为null，HashTable不允许 HashMap继承自AbstractMap类。但二者都实现了Map接口。Hashtable继承自Dictionary类，Dictionary类是一个已经被废弃的类（见其源码中的注释）。父类都被废弃，自然而然也没人用它的子类Hashtable了。 遍历方式： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 Enumeration接口的功能和Iterator接口的功能是重复的，主要区别其实就是Iterator可以删除元素，但是Enumration却不能 .HashMap不能保证元素的顺序，而LinkedHashMap可以保持数据的插入顺序，TreeMap可以按照键值进行排序（可自定比较器） Q: Hashmap 是怎样实现的？为什么要用红黑树，而不用平衡二叉树？为什么在 1.8 中链表大于 8 时会转红黑树？HashMap 是线性安全的嘛？如何保证安全？A: JDK1.8 Hashmap 的底层数据结构是数组+链表+红黑树 为什么不用二叉树？红黑树是一种平衡的二叉树，其插入、删除、查找的最坏时间复杂度都为O(logn)，避免了二叉树最坏情况下的 O(n)时间复杂度。 为什么不用平衡二叉树？平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。 Q:深拷贝和浅拷贝区别?A:浅拷贝:复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。 深拷贝: 将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变 Q: 线程生命周期A：当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。 yield方法使得线程自动放弃当前分得的CPU时间，等待下一轮CPU时间的分配。相当于说：我执行足够长了，该轮到你执行一会了。 suspend与resume方法对应使用，suspend让线程阻塞，等待resume方法调用，线程才能解除阻塞状态。 Q: 创建多线程的方法A: 继承Thread类 重写run方法，因为是继承的，不能再继承其他 多个线程不能共享资源 实现Runnable接口 实现Callable接口通过FutureTask包装器来创建Thread线程 与使用Runnable相比， Callable功能更强大些 1 相比run()方法，可以有返回值 2 方法可以抛出异常 3 支持泛型的返回值 使用ExecutorService、Callable、Future实现有返回结果的多线程。 Q：start 与 run 区别A： start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 Q: JAVA锁乐观锁: 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 悲观锁: 悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 同步锁：当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 死锁： 何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 Q:如何在两个线程之间共享数据A:Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法: 将数据抽象成一个类，并将数据的操作作为这个类的方法 Runnable 对象作为一个类的内部类 Q:栈与队列 栈的应用栈的经典应用:括号匹配、表达式求值和递归函数的递归栈 队列的经典应用:二叉树的层次遍历中 3，Spring 原理部分Q: Spring Bean 生命周期A: 简答版，更详细的查看另外的一个比较文件 实例化 Instantiation属性赋值 Populate初始化 Initialization销毁 Destruction Q: Spring Boot 是怎样启动的？A:（标准版） 运行 SpringApplication.run() 方法。 确定应用程序类型。 加载所有的初始化器。 加载所有的监听器。 设置程序运行的主类。 开启计时器。 将java.awt.headless设置为true。 获取并启用监听器 设置应用程序参数 准备环境变量 忽略bean信息 打印 banner 信息 创建应用程序的上下文 实例化异常报告器 准备上下文环境 刷新上下文 刷新上下文后置处理 结束计时器 发布上下文准备就绪事件 执行自定义的run方法 简答版： 加载并且启动监听器 创建项目运行环境，加载配置 初始化 Spring 容器 执行 Spring 容器前置处理器 刷新 Spring 容器 执行 Spring 后置处理器 发布事件 执行自定义执行器 返回容器 Q: Spring MvC执行流程 （1）当用户通过浏览器发起一个HTTP请求，请求直接到前端控制器DispatcherServlet；（2）前端控制器接收到请求以后调用处理器映射器HandlerMapping，处理器映射器根据请求的URL找到具体的Handler，并将它返回给前端控制器；（3）前端控制器调用处理器适配器HandlerAdapter去适配调用Handler；（4）处理器适配器会根据Handler去调用真正的处理器去处理请求，并且处理对应的业务逻辑；（5）当处理器处理完业务之后，会返回一个ModelAndView对象给处理器适配器，HandlerAdapter再将该对象返回给前端控制器；这里的Model是返回的数据对象，View是逻辑上的View。（6）前端控制器DispatcherServlet将返回的ModelAndView对象传给视图解析器ViewResolver进行解析，解析完成之后就会返回一个具体的视图View给前端控制器。（ViewResolver根据逻辑的View查找具体的View）（7）前端控制器DispatcherServlet将具体的视图进行渲染，渲染完成之后响应给用户（浏览器显示）。 Q:5 种不同方式的自动装配？A:Spring 装配包括手动装配和自动装配，手动装配是有基于 xml 装配、构造方法、setter 方法等 自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。 no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。 byName：通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被 设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多 个 bean 符合条件，则抛出错误。 constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数 的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式 Q:Spring MVC和Spring Boot有什么区别？A: Spring mvc 是web层的框架，通过Controller提供Http接口服务。 Spring Boot 是一种快速搭建的脚手架，通过依赖各种Starter，省略了Spring特别多而繁琐的xml配置。 两者作为Spring生态中的组件，产生时间不同，spring mvc很早就诞生，例如之前最主流的企业开发框架ssm，就用到了Spring mvc。Spring Boot作为后起之秀，通过“约定大于配置”来减少许多配置，大大的提高了生产力。 Q:JAVA过滤器（Filter）与拦截器（Interceptor）区别及关系1、过滤器是基于函数回调，而拦截器是基于java的反射机制； 2、过滤器是servlet规范规定的，只能用于web程序中，而拦截器是在spring容器中，它不依赖servlet容器 3、过滤器可以拦截几乎所有的请求(包含对静态资源的请求)，而拦截器只拦截action请求(不拦截静态资源请求) 4、过滤器不能访问action上下文及值栈里的对象，而拦截器都是可以的。 5、拦截器可以获取spring容器里的对象，而过滤器是不行的 6、拦截器在action的生命周期内是可以多次调用，而过滤器只在容器初始化时被调用一次。 7、拦截器是被包裹在过滤器之中。 Q: Spring 中的事务 spring事务的实现方式spring框架提供了两种事务实现方式：编程式事务、声明式事务编程式事务：在代码中进行事务控制。优点：精度高。缺点：代码耦合度高声明式事务：通过@Transactional注解实现事务控制 spring事务的底层原理事务的操作本来应该由数据库进行控制，但是为了方便用户进行业务逻辑的控制，spring对事务功能进行了扩展实现。一般我们很少使用编程式事务，更多的是使用@Transactional注解实现。当使用了@Transactional注解后事务的自动功能就会关闭，由spring帮助实现事务的控制。Spring的事务管理是通过AOP代理实现的，对被代理对象的每个方法进行拦截，在方法执行前启动事务，在方法执行完成后根据是否有异常及异常的类型进行提交或回滚。Spring AOP动态代理机制：Spring在运行期间会为目标对象生成一个代理对象，并在代理对象中实现对目标对象的增强。SpringAOP通过两种动态代理机制，实现对目标对象执行横向植入的。代理技术 描述JDK 动态代理 Spring AOP 默认的动态代理方式，若目标对象实现了若干接口，Spring 使用 JDK 的 java.lang.reflect.Proxy 类进行代理。CGLIB 动态代理 若目标对象没有实现任何接口，Spring 则使用 CGLIB 库生成目标对象的子类，以实现对目标对象的代理。 Q: 4，MySQL部分Q: SQL语句执行过程（顺序） FROM 子句组装来自不同数据源的数据； WHERE 子句基于指定的条件对记录行进行筛选； GROUP BY 子句将数据划分为多个分组； 使用聚集函数进行计算； 使用 HAVING 子句筛选分组； 计算所有的表达式； SELECT 的字段； 使用 ORDER BY 对结果集进行排序。 Q:索引哪些情况会失效A: . 查询条件包含or，可能导致索引失效. 如何字段类型是字符串，where时一定用引号括起来，否则索引失效. like通配符可能导致索引失效。. 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。. 在索引列上使用mysql的内置函数，索引失效。. 对索引列运算（如，+、-、*、/），索引失效。. 索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。. 索引字段上使用is null， is not null，可能导致索引失效。. 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。. mysql估计使用全表扫描要比使用索引快,则不使用索引。 Q：数据库索引的原理，为什么要用 B+树，为什么不用二叉树 A:从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树： 为什么不是一般二叉树？ 如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 为什么不是平衡二叉树呢？ 但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。 那为什么不是B树而是B+树呢？ B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快 聚集索引与非聚集索引的区别？A： 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序； Q:SQL优化的一般步骤是什么A: show status 命令了解各种sql的执行频率 通过慢查询日志定位那些执行效率较低的sql语句 explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）","categories":[{"name":"找工作","slug":"找工作","permalink":"https://coder-xbai.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}],"tags":[{"name":"job","slug":"job","permalink":"https://coder-xbai.github.io/tags/job/"}]},{"title":"redis-1","slug":"redis-1","date":"2023-09-05T12:05:11.000Z","updated":"2023-10-25T02:14:08.435Z","comments":true,"path":"2023/09/05/redis-1.html","link":"","permalink":"https://coder-xbai.github.io/2023/09/05/redis-1.html","excerpt":"","text":"Redis 快速上手安装与简单使用安装推荐使用宝塔，或者docker包装 ，更简单，这里是快速上手笔记就不再赘述 推荐几个安装博客吧！ 宝塔安装方式： https://blog.csdn.net/weixin_44695700/article/details/117458317 docker安装方式：https://blog.csdn.net/weixin_45821811/article/details/116211724 1.redis 五大数据类型及常用命令 String（字符串） Hash（哈希，类似 java 里面的 map） List（列表） Set（集合） Zset（sorted set 有序的集合） 1234561、keys * 查看当前库中所有的 key2、exists keyname 判断某个 key 是否存在3、move keyname dbnum 把当前库中的 keyname 这个 key 移动到 dbnum 这个库里面4、expire keyname 秒钟 为给定的 key 设置过期时间5、ttl keyname 查看还有多少秒过期，-1 表示永不过期 -2 表示已过期6、type keyname 查看你的 key 是什么类型 更多命令请查看 ：Redis官方文档 这里的基本部分跳过，后续会整理出详细版本，这里只是应对Redis面试 2. Redis的发布和订阅Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 2.1发布订阅命令行实现 打开一个客户端订阅channel1 SUBSCRIBE channel1 打开另一个客户端，给channel1发布消息hello : publish channel1 hello 打开第一个客户端可以看到发送的消息 注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息 3. Redis_事务_锁机制_秒杀3.1 事务的定义 Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要作用就是串联多个命令防止别的命令插队。 3.2 Multi、Exec、discard从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队 3.3 事务的错误处理如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。 3.3 Redis事务三特性 单独的隔离操作 ： 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行 不保证原子性 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 4. Redis持久化 官网介绍在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 4.1 RDBRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术” 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 流程图如下 RDB的备份 先通过config get dir 查询rdb文件的目录 将*.rdb的文件拷贝到别的地方 rdb的恢复 关闭Redis 先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb 启动Redis, 备份数据会直接加载 优势 适合大规模的数据恢复 对数据完整性和一致性要求不高更适合使用 节省磁盘空间 恢复速度快 劣势 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。 4.2 AOF（Append Only File） 持久化以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作. 默认不开启 AOF持久化流程 （1）客户端的请求写命令会被append追加到AOF缓冲区内； （2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中； （3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量； （4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的； AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） Rewrite压缩 1是什么： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 2重写原理，如何实现重写 AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 触发机制，何时重写 Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发 Rewrite压缩1是什么： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 2重写原理，如何实现重写 AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。 优势 备份机制更稳健，丢失数据概率更低。 可读的日志文本，通过操作AOF稳健，可以处理误操作。 劣势 比起RDB占用更多的磁盘空间。 恢复备份速度要慢。 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成恢复不能。 总结 5. Redis应用问题解决5.1 缓存穿透key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 解决方案 一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。 （1） 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟 （2） 设置可访问的名单（白名单）： 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 （3） 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。 布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。) 将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力。 （4） 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务 5.2 缓存击穿描述：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案： （1）预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 （2）实时调整：现场监控哪些数据热门，实时调整key的过期时长 （3**）使用互斥锁(mutex key) 5.3 缓存雪崩描述：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。 缓存失效瞬间 解决方案 （1） 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等） （2） 使用锁或队列： 用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况 （3） 设置过期标志更新缓存： 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。 （4） 将缓存失效时间分散开： 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"redis面试常问","slug":"redis面试常问","permalink":"https://coder-xbai.github.io/tags/redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"}]},{"title":"t1","slug":"t1","date":"2023-07-08T10:54:55.000Z","updated":"2023-09-06T03:50:31.270Z","comments":true,"path":"2023/07/08/t1.html","link":"","permalink":"https://coder-xbai.github.io/2023/07/08/t1.html","excerpt":"","text":"这是个测试文档","categories":[],"tags":[]},{"title":"Spring框架笔记","slug":"spring6","date":"2023-06-29T02:31:32.000Z","updated":"2023-07-08T11:59:40.794Z","comments":true,"path":"2023/06/29/spring6.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/29/spring6.html","excerpt":"","text":"Spring6 1、概述1.1、Spring是什么？Spring 是一款主流的 Java EE 轻量级开源框架 ，Spring 由“Spring 之父”Rod Johnson 提出并创立，其目的是用于简化 Java 企业级应用的开发难度和开发周期。Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring 框架除了自己提供功能外，还提供整合其他技术和框架的能力。 Spring 自诞生以来备受青睐，一直被广大开发人员作为 Java 企业级应用程序开发的首选。时至今日，Spring 俨然成为了 Java EE 代名词，成为了构建 Java EE 应用的事实标准。 自 2004 年 4 月，Spring 1.0 版本正式发布以来，Spring 已经步入到了第 6 个大版本，也就是 Spring 6。本课程采用Spring当前最新发布的正式版本6.0.2。 1.2、Spring 的狭义和广义在不同的语境中，Spring 所代表的含义是不同的。下面我们就分别从“广义”和“狭义”两个角度，对 Spring 进行介绍。 广义的 Spring：Spring 技术栈 广义上的 Spring 泛指以 Spring Framework 为核心的 Spring 技术栈。 经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。 这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。 狭义的 Spring：Spring Framework 狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。 Spring 框架是一个分层的、面向切面的 Java 应用程序的一站式轻量级解决方案，它是 Spring 技术栈的核心和基础，是为了解决企业级应用开发的复杂性而创建的。 Spring 有两个最核心模块： IoC 和 AOP。 IoC：Inverse of Control 的简写，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。 AOP：Aspect Oriented Programming 的简写，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 1.3、Spring Framework特点 非侵入式：使用 Spring Framework 开发应用程序时，Spring 对应用程序本身的结构影响非常小。对领域模型可以做到零污染；对功能性组件也只需要使用几个简单的注解进行标记，完全不会破坏原有结构，反而能将组件结构进一步简化。这就使得基于 Spring Framework 开发应用程序时结构清晰、简洁优雅。 控制反转：IoC——Inversion of Control，翻转资源获取方向。把自己创建资源、向环境索取资源变成环境将资源准备好，我们享受资源注入。 面向切面编程：AOP——Aspect Oriented Programming，在不修改源代码的基础上增强代码功能。 容器：Spring IoC 是一个容器，因为它包含并且管理组件对象的生命周期。组件享受到了容器化的管理，替程序员屏蔽了组件创建过程中的大量细节，极大的降低了使用门槛，大幅度提高了开发效率。 组件化：Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象。这使得我们可以基于一个个功能明确、边界清晰的组件有条不紊的搭建超大型复杂应用系统。 一站式：在 IoC 和 AOP 的基础上可以整合各种企业应用的开源框架和优秀的第三方类库。而且 Spring 旗下的项目已经覆盖了广泛领域，很多方面的功能性需求可以在 Spring Framework 的基础上全部使用 Spring 来实现。 1.4、Spring模块组成官网地址：https://spring.io/ 上图中包含了 Spring 框架的所有模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。下面分别对这些模块的作用进行简单介绍。 ①Spring Core（核心容器） spring core提供了IOC,DI,Bean配置装载创建的核心实现。核心概念： Beans、BeanFactory、BeanDefinitions、ApplicationContext。 spring-core ：IOC和DI的基本实现 spring-beans：BeanFactory和Bean的装配管理(BeanFactory) spring-context：Spring context上下文，即IOC容器(AppliactionContext) spring-expression：spring表达式语言 ②Spring AOP spring-aop：面向切面编程的应用模块，整合ASM，CGLib，JDK Proxy spring-aspects：集成AspectJ，AOP应用框架 spring-instrument：动态Class Loading模块 ③Spring Data Access spring-jdbc：spring对JDBC的封装，用于简化jdbc操作 spring-orm：java对象与数据库数据的映射框架 spring-oxm：对象与xml文件的映射框架 spring-jms： Spring对Java Message Service(java消息服务)的封装，用于服务之间相互通信 spring-tx：spring jdbc事务管理 ④Spring Web spring-web：最基础的web支持，建立于spring-context之上，通过servlet或listener来初始化IOC容器 spring-webmvc：实现web mvc spring-websocket：与前端的全双工通信协议 spring-webflux：Spring 5.0提供的，用于取代传统java servlet，非阻塞式Reactive Web框架，异步，非阻塞，事件驱动的服务 ⑤Spring Message Spring-messaging：spring 4.0提供的，为Spring集成一些基础的报文传送服务 ⑥Spring test spring-test：集成测试支持，主要是对junit的封装 1.5、Spring6特点1.5.1、版本要求（1）Spring6要求JDK最低版本是JDK17 1.5.2、本课程软件版本（1）IDEA开发工具：2022.1.2 （2）JDK：Java17（Spring6要求JDK最低版本是Java17） （3）Spring：6.0.2 2、入门2.1、环境要求 JDK：Java17+（Spring6要求JDK最低版本是Java17） Maven：3.6+ Spring：6.0.2 2.2、构建模块（1）构建父模块spring6 在idea中，依次单击 File -&gt; New -&gt; Project -&gt; New Project 点击“Create” 删除src目录 （2）构建子模块spring6-first 点击 Create 完成 2.3、程序开发2.3.1、引入依赖https://spring.io/projects/spring-framework#learn 添加依赖： 12345678910111213141516&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 查看依赖： 2.3.2、创建java类12345678package com.atguigu.spring6.bean;public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 2.3.3、创建配置文件在resources目录创建一个 Spring 配置文件 beans.xml（配置文件名称可随意命名，如：springs.xm） 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 配置HelloWorld所对应的bean，即将HelloWorld的对象交给Spring的IOC容器管理 通过bean标签配置IOC容器所管理的bean 属性： id：设置bean的唯一标识 class：设置bean所对应类型的全类名 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 2.3.4、创建测试类测试123456789101112131415package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); &#125;&#125; 2.3.5、运行测试程序 2.4、程序分析1. 底层是怎么创建对象的，是通过反射机制调用无参数构造方法吗？ 修改HelloWorld类： 123456789101112package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 执行结果： 测试得知：创建对象时确实调用了无参数构造方法。 2. Spring是如何创建对象的呢？原理是什么？ 12345// dom4j解析beans.xml文件，从中获取class属性值，类的全类名 // 通过反射机制调用无参数构造方法创建对象 Class clazz = Class.forName(&quot;com.atguigu.spring6.bean.HelloWorld&quot;); //Object obj = clazz.newInstance(); Object object = clazz.getDeclaredConstructor().newInstance(); 3. 把创建好的对象存储到一个什么样的数据结构当中了呢？ bean对象最终存储在spring容器中，在spring源码底层就是一个map集合，存储bean的map在DefaultListableBeanFactory类中： 1private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); Spring容器加载到Bean类时 , 会把这个类的描述信息, 以包名加类名的方式存到beanDefinitionMap 中,Map&lt;String,BeanDefinition&gt; , 其中 String是Key , 默认是类名首字母小写 , BeanDefinition , 存的是类的定义(描述信息) , 我们通常叫BeanDefinition接口为 : bean的定义对象。 2.5、启用Log4j2日志框架2.5.1、Log4j2日志概述在项目开发中，日志十分的重要，不管是记录运行情况还是定位线上问题，都离不开对日志的分析。日志记录了系统行为的时间、地点、状态等相关信息，能够帮助我们了解并监控系统状态，在发生错误或者接近某种危险状态时能够及时提醒我们处理，同时在系统产生问题时，能够帮助我们快速的定位、诊断并解决问题。 Apache Log4j2是一个开源的日志记录组件，使用非常的广泛。在工程中以易用方便代替了 System.out 等打印语句，它是JAVA下最流行的日志输入工具。 Log4j2主要由几个重要的组件构成： （1）日志信息的优先级，日志信息的优先级从高到低有TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL TRACE：追踪，是最低的日志级别，相当于追踪程序的执行 DEBUG：调试，一般在开发中，都将其设置为最低的日志级别 INFO：信息，输出重要的信息，使用较多 WARN：警告，输出警告的信息 ERROR：错误，输出错误信息 FATAL：严重错误 这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示 （2）日志信息的输出目的地，日志信息的输出目的地指定了日志将打印到控制台还是文件中； （3）日志信息的输出格式，而输出格式则控制了日志信息的显示内容。 2.5.2、引入Log4j2依赖1234567891011&lt;!--log4j2的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt;&lt;/dependency&gt; 2.5.3、加入日志配置文件在类的根路径下提供log4j2.xml配置文件（文件名固定为：log4j2.xml，文件必须放到类根路径下。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;loggers&gt; &lt;!-- level指定日志级别，从低到高的优先级： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL trace：追踪，是最低的日志级别，相当于追踪程序的执行 debug：调试，一般在开发中，都将其设置为最低的日志级别 info：信息，输出重要的信息，使用较多 warn：警告，输出警告的信息 error：错误，输出错误信息 fatal：严重错误 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;spring6log&quot;/&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;spring6log&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%t] %-3level %logger&#123;1024&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt; &lt;File name=&quot;log&quot; fileName=&quot;d:/spring6_log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息， 每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档--&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;d:/spring6_log/app.log&quot; filePattern=&quot;log/$$&#123;date:yyyy-MM&#125;/app-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &#x27;at&#x27; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;50MB&quot;/&gt; &lt;!-- DefaultRolloverStrategy属性如不设置， 则默认为最多同一文件夹下7个文件，这里设置了20 --&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt;&lt;/configuration&gt; 2.5.4、测试运行原测试程序 运行原测试程序，多了spring打印日志 2.5.5、使用日志123456789101112public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld helloworld = (HelloWorld) ac.getBean(&quot;helloWorld&quot;); helloworld.sayHello(); logger.info(&quot;执行成功&quot;); &#125;&#125; 控制台： 3、容器：IoCIoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。 IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。 3.1、IoC容器3.1.1、控制反转（IoC） 控制反转是一种思想。 控制反转是为了降低程序耦合度，提高程序扩展力。 控制反转，反转的是什么？ 将对象的创建权利交出去，交给第三方容器负责。 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 控制反转这种思想如何实现呢？ DI（Dependency Injection）：依赖注入 3.1.2、依赖注入DI（Dependency Injection）：依赖注入，依赖注入实现了控制反转的思想。 依赖注入： 指Spring创建对象的过程中，将对象依赖属性通过配置进行注入 依赖注入常见的实现方式包括两种： 第一种：set注入 第二种：构造注入 所以结论是：IOC 就是一种控制反转的思想， 而 DI 是对IoC的一种具体实现。 Bean管理说的是：Bean对象的创建，以及Bean对象中属性的赋值（或者叫做Bean对象之间关系的维护）。 3.1.3、IoC容器在Spring的实现Spring 的 IoC 容器就是 IoC思想的一个落地的产品实现。IoC容器中管理的组件也叫做 bean。在创建 bean 之前，首先需要创建IoC 容器。Spring 提供了IoC 容器的两种实现方式： ①BeanFactory 这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。 ②ApplicationContext BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。 ③ApplicationContext的主要实现类 类型名 简介 ClassPathXmlApplicationContext 通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象 FileSystemXmlApplicationContext 通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象 ConfigurableApplicationContext ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。 WebApplicationContext 专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。 3.2、基于XML管理Bean3.2.1、搭建子模块spring6-ioc-xml①搭建模块 搭建方式如：spring-first ②引入配置文件 引入spring-first模块配置文件：beans.xml、log4j2.xml ③添加依赖 12345678910111213141516171819202122232425262728&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ④引入java类 引入spring-first模块java及test目录下实体类 12345678910111213package com.atguigu.spring6.bean;public class HelloWorld &#123; public HelloWorld() &#123; System.out.println(&quot;无参数构造方法执行&quot;); &#125; public void sayHello()&#123; System.out.println(&quot;helloworld&quot;); &#125;&#125; 1234567891011121314151617package com.atguigu.spring6.bean;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class HelloWorldTest &#123; private Logger logger = LoggerFactory.getLogger(HelloWorldTest.class); @Test public void testHelloWorld()&#123; &#125;&#125; 3.2.2、实验一：获取bean①方式一：根据id获取由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。 ②方式二：根据类型获取123456@Testpublic void testHelloWorld1()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(HelloWorld.class); bean.sayHello();&#125; ③方式三：根据id和类型123456@Testpublic void testHelloWorld2()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class); bean.sayHello();&#125; ④注意的地方当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个 当IOC容器中一共配置了两个： 12&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; 根据类型获取时会抛出异常： org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo ⑤扩展知识如果组件类实现了接口，根据接口类型可以获取 bean 吗？ 可以，前提是bean唯一 如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？ 不行，因为bean不唯一 结论 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系 3.2.3、实验二：依赖注入之setter注入①创建学生类Student 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.spring6.bean;public class Student &#123; private Integer id; private String name; private Integer age; private String sex; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ②配置bean时为属性赋值 spring-di.xml 123456789&lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt; &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt; &lt;!-- value属性：指定属性值 --&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testDIBySet()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentOne&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.4、实验三：依赖注入之构造器注入①在Student类中添加有参构造 123456public Student(Integer id, String name, Integer age, String sex) &#123; this.id = id; this.name = name; this.age = age; this.sex = sex;&#125; ②配置bean spring-di.xml 123456&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 注意： constructor-arg标签还有两个属性可以进一步描述构造器参数： index属性：指定参数所在位置的索引（从0开始） name属性：指定参数名 ③测试 123456@Testpublic void testDIByConstructor()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(studentOne);&#125; 3.2.5、实验四：特殊值处理①字面量赋值 什么是字面量？ int a = 10; 声明一个变量a，初始化为10，此时a就不代表字母a了，而是作为一个变量的名字。当我们引用a的时候，我们实际上拿到的值是10。 而如果a是带引号的：’a’，那么它现在不是一个变量，它就是代表a这个字母本身，这就是字面量。所以字面量没有引申含义，就是我们看到的这个数据本身。 12&lt;!-- 使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量 --&gt;&lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; ②null值123&lt;property name=&quot;name&quot;&gt; &lt;null /&gt;&lt;/property&gt; 注意： 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 以上写法，为name所赋的值是字符串null ③xml实体123&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt; ④CDATA节1234567&lt;property name=&quot;expression&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt; 3.2.6、实验五：为对象类型属性赋值①创建班级类Clazz 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean public class Clazz &#123; private Integer clazzId; private String clazzName; public Integer getClazzId() &#123; return clazzId; &#125; public void setClazzId(Integer clazzId) &#123; this.clazzId = clazzId; &#125; public String getClazzName() &#123; return clazzName; &#125; public void setClazzName(String clazzName) &#123; this.clazzName = clazzName; &#125; @Override public String toString() &#123; return &quot;Clazz&#123;&quot; + &quot;clazzId=&quot; + clazzId + &quot;, clazzName=&#x27;&quot; + clazzName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Clazz() &#123; &#125; public Clazz(Integer clazzId, String clazzName) &#123; this.clazzId = clazzId; this.clazzName = clazzName; &#125;&#125; ②修改Student类 在Student类中添加以下代码： 123456789private Clazz clazz;public Clazz getClazz() &#123; return clazz;&#125;public void setClazz(Clazz clazz) &#123; this.clazz = clazz;&#125; 方式一：引用外部bean配置Clazz类型的bean： 1234&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 为Student中的clazz属性赋值： 12345678&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 错误演示： 1234567&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值 方式二：内部bean1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt; &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 方式三：级联属性赋值123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.2.7、实验六：为数组类型属性赋值①修改Student类 在Student类中添加以下代码： 123456789private String[] hobbies;public String[] getHobbies() &#123; return hobbies;&#125;public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies;&#125; ②配置bean 123456789101112131415&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 3.2.8、实验七：为集合类型属性赋值①为List集合类型属性赋值在Clazz类中添加以下代码： 123456789private List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() &#123; return students;&#125;public void setStudents(List&lt;Student&gt; students) &#123; this.students = students;&#125; 配置bean： 1234567891011&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可 ②为Map集合类型属性赋值创建教师类Teacher： 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean;public class Teacher &#123; private Integer teacherId; private String teacherName; public Integer getTeacherId() &#123; return teacherId; &#125; public void setTeacherId(Integer teacherId) &#123; this.teacherId = teacherId; &#125; public String getTeacherName() &#123; return teacherName; &#125; public void setTeacherName(String teacherName) &#123; this.teacherName = teacherName; &#125; public Teacher(Integer teacherId, String teacherName) &#123; this.teacherId = teacherId; this.teacherName = teacherName; &#125; public Teacher() &#123; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;teacherId=&quot; + teacherId + &quot;, teacherName=&#x27;&quot; + teacherName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 在Student类中添加以下代码： 123456789private Map&lt;String, Teacher&gt; teacherMap;public Map&lt;String, Teacher&gt; getTeacherMap() &#123; return teacherMap;&#125;public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) &#123; this.teacherMap = teacherMap;&#125; 配置bean： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; ③引用集合类型的bean123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--list集合类型的bean--&gt;&lt;util:list id=&quot;students&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt;&lt;!--map集合类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt;&lt;/util:map&gt;&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 使用util:list、util:map标签必须引入相应的命名空间 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 3.2.9、实验八：p命名空间引入p命名空间 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 引入p命名空间后，可以通过以下方式为bean的各个属性赋值 12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring6.bean.Student&quot; p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; 3.2.10、实验九：引入外部属性文件①加入依赖 12345678910111213 &lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt; ②创建外部属性文件 1234jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver ③引入属性文件 引入context 名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 12&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 注意：在使用 context:property-placeholder 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 ④配置bean 123456&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; ⑤测试 1234567@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); DataSource dataSource = ac.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 3.2.11、实验十：bean的作用域①概念 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 request 在一个请求范围内有效 session 在一个会话范围内有效 ②创建类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.atguigu.spring6.bean;public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; ③配置bean 123&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testBeanScope()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;); User user1 = ac.getBean(User.class); User user2 = ac.getBean(User.class); System.out.println(user1==user2);&#125; 3.2.12、实验十一：bean生命周期①具体的生命周期过程 bean对象创建（调用无参构造器） 给bean对象设置属性 bean的后置处理器（初始化之前） bean对象初始化（需在配置bean时指定初始化方法） bean的后置处理器（初始化之后） bean对象就绪可以使用 bean对象销毁（需在配置bean时指定销毁方法） IOC容器关闭 ②修改类User 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class User &#123; private Integer id; private String username; private String password; private Integer age; public User() &#123; System.out.println(&quot;生命周期：1、创建对象&quot;); &#125; public User(Integer id, String username, String password, Integer age) &#123; this.id = id; this.username = username; this.password = password; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; System.out.println(&quot;生命周期：2、依赖注入&quot;); this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void initMethod()&#123; System.out.println(&quot;生命周期：3、初始化&quot;); &#125; public void destroyMethod()&#123; System.out.println(&quot;生命周期：5、销毁&quot;); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 注意其中的initMethod()和destroyMethod()，可以通过配置bean指定为初始化和销毁的方法 ③配置bean 12345678&lt;!-- 使用init-method属性指定初始化方法 --&gt;&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testLife()&#123; ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;); User bean = ac.getBean(User.class); System.out.println(&quot;生命周期：4、通过IOC容器获取bean并使用&quot;); ac.close();&#125; ⑤bean的后置处理器 bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行 创建bean的后置处理器： 12345678910111213141516171819package com.atguigu.spring6.process; import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;☆☆☆&quot; + beanName + &quot; = &quot; + bean); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;★★★&quot; + beanName + &quot; = &quot; + bean); return bean; &#125;&#125; 在IOC容器中配置后置处理器： 12&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.atguigu.spring6.process.MyBeanProcessor&quot;/&gt; 3.2.13、实验十二：FactoryBean①简介 FactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。 将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* * Copyright 2002-2020 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.springframework.beans.factory;import org.springframework.lang.Nullable;/** * Interface to be implemented by objects used within a &#123;@link BeanFactory&#125; which * are themselves factories for individual objects. If a bean implements this * interface, it is used as a factory for an object to expose, not directly as a * bean instance that will be exposed itself. * * &lt;p&gt;&lt;b&gt;NB: A bean that implements this interface cannot be used as a normal bean.&lt;/b&gt; * A FactoryBean is defined in a bean style, but the object exposed for bean * references (&#123;@link #getObject()&#125;) is always the object that it creates. * * &lt;p&gt;FactoryBeans can support singletons and prototypes, and can either create * objects lazily on demand or eagerly on startup. The &#123;@link SmartFactoryBean&#125; * interface allows for exposing more fine-grained behavioral metadata. * * &lt;p&gt;This interface is heavily used within the framework itself, for example for * the AOP &#123;@link org.springframework.aop.framework.ProxyFactoryBean&#125; or the * &#123;@link org.springframework.jndi.JndiObjectFactoryBean&#125;. It can be used for * custom components as well; however, this is only common for infrastructure code. * * &lt;p&gt;&lt;b&gt;&#123;@code FactoryBean&#125; is a programmatic contract. Implementations are not * supposed to rely on annotation-driven injection or other reflective facilities.&lt;/b&gt; * &#123;@link #getObjectType()&#125; &#123;@link #getObject()&#125; invocations may arrive early in the * bootstrap process, even ahead of any post-processor setup. If you need access to * other beans, implement &#123;@link BeanFactoryAware&#125; and obtain them programmatically. * * &lt;p&gt;&lt;b&gt;The container is only responsible for managing the lifecycle of the FactoryBean * instance, not the lifecycle of the objects created by the FactoryBean.&lt;/b&gt; Therefore, * a destroy method on an exposed bean object (such as &#123;@link java.io.Closeable#close()&#125; * will &lt;i&gt;not&lt;/i&gt; be called automatically. Instead, a FactoryBean should implement * &#123;@link DisposableBean&#125; and delegate any such close call to the underlying object. * * &lt;p&gt;Finally, FactoryBean objects participate in the containing BeanFactory&#x27;s * synchronization of bean creation. There is usually no need for internal * synchronization other than for purposes of lazy initialization within the * FactoryBean itself (or the like). * * @author Rod Johnson * @author Juergen Hoeller * @since 08.03.2003 * @param &lt;T&gt; the bean type * @see org.springframework.beans.factory.BeanFactory * @see org.springframework.aop.framework.ProxyFactoryBean * @see org.springframework.jndi.JndiObjectFactoryBean */public interface FactoryBean&lt;T&gt; &#123; /** * The name of an attribute that can be * &#123;@link org.springframework.core.AttributeAccessor#setAttribute set&#125; on a * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125; so that * factory beans can signal their object type when it can&#x27;t be deduced from * the factory bean class. * @since 5.2 */ String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;; /** * Return an instance (possibly shared or independent) of the object * managed by this factory. * &lt;p&gt;As with a &#123;@link BeanFactory&#125;, this allows support for both the * Singleton and Prototype design pattern. * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of * the call (for example because it is involved in a circular reference), * throw a corresponding &#123;@link FactoryBeanNotInitializedException&#125;. * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return &#123;@code null&#125; * objects. The factory will consider this as normal value to be used; it * will not throw a FactoryBeanNotInitializedException in this case anymore. * FactoryBean implementations are encouraged to throw * FactoryBeanNotInitializedException themselves now, as appropriate. * @return an instance of the bean (can be &#123;@code null&#125;) * @throws Exception in case of creation errors * @see FactoryBeanNotInitializedException */ @Nullable T getObject() throws Exception; /** * Return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known in advance. * &lt;p&gt;This allows one to check for specific types of beans without * instantiating objects, for example on autowiring. * &lt;p&gt;In the case of implementations that are creating a singleton object, * this method should try to avoid singleton creation as far as possible; * it should rather estimate the type in advance. * For prototypes, returning a meaningful type here is advisable too. * &lt;p&gt;This method can be called &lt;i&gt;before&lt;/i&gt; this FactoryBean has * been fully initialized. It must not rely on state created during * initialization; of course, it can still use such state if available. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Autowiring will simply ignore FactoryBeans that return * &#123;@code null&#125; here. Therefore it is highly recommended to implement * this method properly, using the current state of the FactoryBean. * @return the type of object that this FactoryBean creates, * or &#123;@code null&#125; if not known at the time of the call * @see ListableBeanFactory#getBeansOfType */ @Nullable Class&lt;?&gt; getObjectType(); /** * Is the object managed by this factory a singleton? That is, * will &#123;@link #getObject()&#125; always return the same object * (a reference that can be cached)? * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; If a FactoryBean indicates to hold a singleton object, * the object returned from &#123;@code getObject()&#125; might get cached * by the owning BeanFactory. Hence, do not return &#123;@code true&#125; * unless the FactoryBean always exposes the same reference. * &lt;p&gt;The singleton status of the FactoryBean itself will generally * be provided by the owning BeanFactory; usually, it has to be * defined as singleton there. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This method returning &#123;@code false&#125; does not * necessarily indicate that returned objects are independent instances. * An implementation of the extended &#123;@link SmartFactoryBean&#125; interface * may explicitly indicate independent instances through its * &#123;@link SmartFactoryBean#isPrototype()&#125; method. Plain &#123;@link FactoryBean&#125; * implementations which do not implement this extended interface are * simply assumed to always return independent instances if the * &#123;@code isSingleton()&#125; implementation returns &#123;@code false&#125;. * &lt;p&gt;The default implementation returns &#123;@code true&#125;, since a * &#123;@code FactoryBean&#125; typically manages a singleton instance. * @return whether the exposed object is a singleton * @see #getObject() * @see SmartFactoryBean#isPrototype() */ default boolean isSingleton() &#123; return true; &#125;&#125; ②创建类UserFactoryBean 123456789101112package com.atguigu.spring6.bean;public class UserFactoryBean implements FactoryBean&lt;User&gt; &#123; @Override public User getObject() throws Exception &#123; return new User(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return User.class; &#125;&#125; ③配置bean 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring6.bean.UserFactoryBean&quot;&gt;&lt;/bean&gt; ④测试 1234567@Testpublic void testUserFactoryBean()&#123; //获取IOC容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-factorybean.xml&quot;); User user = (User) ac.getBean(&quot;user&quot;); System.out.println(user);&#125; 3.2.14、实验十三：基于xml自动装配 自动装配： 根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值 ①场景模拟 创建类UserController 1234567891011121314package com.atguigu.spring6.autowire.controllerpublic class UserController &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void saveUser()&#123; userService.saveUser(); &#125;&#125; 创建接口UserService 123456package com.atguigu.spring6.autowire.servicepublic interface UserService &#123; void saveUser();&#125; 创建类UserServiceImpl实现接口UserService 123456789101112131415package com.atguigu.spring6.autowire.service.implpublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void saveUser() &#123; userDao.saveUser(); &#125;&#125; 创建接口UserDao 123456package com.atguigu.spring6.autowire.daopublic interface UserDao &#123; void saveUser();&#125; 创建类UserDaoImpl实现接口UserDao 123456789package com.atguigu.spring6.autowire.dao.implpublic class UserDaoImpl implements UserDao &#123; @Override public void saveUser() &#123; System.out.println(&quot;保存成功&quot;); &#125;&#125; ②配置bean 使用bean标签的autowire属性设置自动装配效果 自动装配方式：byType byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException 12345&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值 1234567&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; ③测试 123456@Testpublic void testAutoWireByXML()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;autowire-xml.xml&quot;); UserController userController = ac.getBean(UserController.class); userController.saveUser();&#125; 3.3、基于注解管理Bean（☆）从 Java 5 开始，Java 增加了对注解（Annotation）的支持，它是代码中的一种特殊标记，可以在编译、类加载和运行时被读取，执行相应的处理。开发人员可以通过注解在不改变原有代码和逻辑的情况下，在源代码中嵌入补充信息。 Spring 从 2.5 版本开始提供了对注解技术的全面支持，我们可以使用注解来实现自动装配，简化 Spring 的 XML 配置。 Spring 通过注解实现自动装配的步骤如下： 引入依赖 开启组件扫描 使用注解定义 Bean 依赖注入 3.3.1、搭建子模块spring6-ioc-annotation①搭建模块 搭建方式如：spring6-ioc-xml ②引入配置文件 引入spring-ioc-xml模块日志log4j2.xml ③添加依赖 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.3.2、开启组件扫描Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 context:component-scan 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描功能--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注意：在使用 context:component-scan 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 情况一：最基本的扫描方式 12&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; 情况二：指定要排除的组件 12345678910&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 情况三：仅扫描指定组件 123456789101112&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 3.3.3、使用注解定义 BeanSpring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 3.3.4、实验一：@Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】 查看源码： 1234567891011121314package org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 源码中有两处需要注意： 第一处：该注解可以标注在哪里？ 构造方法上 方法上 形参上 属性上 注解上 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。 ①场景一：属性注入创建UserDao接口 123456package com.atguigu.spring6.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 12345678910111213141516171819package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 创建UserController类 123456789101112131415161718package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试一 1234567891011121314151617181920212223package com.atguigu.spring6.bean;import com.atguigu.spring6.controller.UserController;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserTest &#123; private Logger logger = LoggerFactory.getLogger(UserTest.class); @Test public void testAnnotation()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;); &#125;&#125; 测试结果： 以上构造方法和setter方法都没有提供，经过测试，仍然可以注入成功。 ②场景二：set注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ③场景三：构造方法注入修改UserServiceImpl类 1234567891011121314151617181920212223package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 12345678910111213141516171819202122package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; @Autowired public UserController(UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ④场景四：形参上注入修改UserServiceImpl类 12345678910111213141516171819202122package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl(@Autowired UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 修改UserController类 123456789101112131415161718192021package com.atguigu.spring6.controller;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123; private UserService userService; public UserController(@Autowired UserService userService) &#123; this.userService = userService; &#125; public void out() &#123; userService.out(); System.out.println(&quot;Controller层执行结束。&quot;); &#125;&#125; 测试：成功调用 ⑤场景五：只有一个构造函数，无注解修改UserServiceImpl类 123456789101112131415161718192021222324package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当有参数的构造方法只有一个时，@Autowired注解可以省略。 说明：有多个构造方法时呢？大家可以测试（再添加一个无参构造函数），测试报错 ⑥场景六：@Autowired注解和@Qualifier注解联合添加dao层实现 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoRedisImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Redis Dao层执行结束&quot;); &#125;&#125; 测试：测试异常 错误信息中说：不能装配，UserDao这个Bean的数量等于2 怎么解决这个问题呢？当然要byName，根据名称进行装配了。 修改UserServiceImpl类 1234567891011121314151617181920package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired @Qualifier(&quot;userDaoImpl&quot;) // 指定bean的名字 private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 总结 @Autowired注解可以出现在：属性上、构造方法上、构造方法的参数上、setter方法上。 当带参数的构造方法只有一个，@Autowired注解可以省略。（） @Autowired注解默认根据类型注入。如果要根据名称注入的话，需要配合@Qualifier注解一起使用。 3.3.5、实验二：@Resource注入@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 源码： 12345678910111213141516171819202122232425262728293031323334package jakarta.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(Resources.class)public @interface Resource &#123; String name() default &quot;&quot;; String lookup() default &quot;&quot;; Class&lt;?&gt; type() default Object.class; Resource.AuthenticationType authenticationType() default Resource.AuthenticationType.CONTAINER; boolean shareable() default true; String mappedName() default &quot;&quot;; String description() default &quot;&quot;; public static enum AuthenticationType &#123; CONTAINER, APPLICATION; private AuthenticationType() &#123; &#125; &#125;&#125; ①场景一：根据name注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource(name = &quot;myUserDao&quot;) private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 ②场景二：name未知注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。 ③场景三 其他情况修改UserServiceImpl类，userDao1属性名不存在 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao1; @Override public void out() &#123; userDao1.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试异常 根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。 @Resource的set注入可以自行测试 总结： @Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个 3.3.6、Spring全注解开发全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。 12345678910package com.atguigu.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)@ComponentScan(&quot;com.atguigu.spring6&quot;)public class Spring6Config &#123;&#125; 测试类 1234567@Testpublic void testAllAnnotation()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class); UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;);&#125; 4、原理-手写IoC我们都知道，Spring框架的IOC是基于Java反射机制实现的，下面我们先回顾一下java反射。 4.1、回顾Java反射Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。 要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect，所以，Class对象是反射的根源。 自定义类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.reflect;public class Car &#123; //属性 private String name; private int age; private String color; //无参数构造 public Car() &#123; &#125; //有参数构造 public Car(String name, int age, String color) &#123; this.name = name; this.age = age; this.color = color; &#125; //普通方法 private void run() &#123; System.out.println(&quot;私有方法-run.....&quot;); &#125; //get和set方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, color=&#x27;&quot; + color + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 编写测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.atguigu.reflect;import org.junit.jupiter.api.Test;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class TestCar &#123; //1、获取Class对象多种方式 @Test public void test01() throws Exception &#123; //1 类名.class Class clazz1 = Car.class; //2 对象.getClass() Class clazz2 = new Car().getClass(); //3 Class.forName(&quot;全路径&quot;) Class clazz3 = Class.forName(&quot;com.atguigu.reflect.Car&quot;); //实例化 Car car = (Car)clazz3.getConstructor().newInstance(); System.out.println(car); &#125; //2、获取构造方法 @Test public void test02() throws Exception &#123; Class clazz = Car.class; //获取所有构造 // getConstructors()获取所有public的构造方法// Constructor[] constructors = clazz.getConstructors(); // getDeclaredConstructors()获取所有的构造方法public private Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor c:constructors) &#123; System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount()); &#125; //指定有参数构造创建对象 //1 构造public// Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);// Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;);// System.out.println(car1); //2 构造private Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class); c2.setAccessible(true); Car car2 = (Car)c2.newInstance(&quot;捷达&quot;, 15, &quot;白色&quot;); System.out.println(car2); &#125; //3、获取属性 @Test public void test03() throws Exception &#123; Class clazz = Car.class; Car car = (Car)clazz.getDeclaredConstructor().newInstance(); //获取所有public属性 //Field[] fields = clazz.getFields(); //获取所有属性（包含私有属性） Field[] fields = clazz.getDeclaredFields(); for (Field field:fields) &#123; if(field.getName().equals(&quot;name&quot;)) &#123; //设置允许访问 field.setAccessible(true); field.set(car,&quot;五菱宏光&quot;); System.out.println(car); &#125; System.out.println(field.getName()); &#125; &#125; //4、获取方法 @Test public void test04() throws Exception &#123; Car car = new Car(&quot;奔驰&quot;,10,&quot;黑色&quot;); Class clazz = car.getClass(); //1 public方法 Method[] methods = clazz.getMethods(); for (Method m1:methods) &#123; //System.out.println(m1.getName()); //执行方法 toString if(m1.getName().equals(&quot;toString&quot;)) &#123; String invoke = (String)m1.invoke(car); //System.out.println(&quot;toString执行了：&quot;+invoke); &#125; &#125; //2 private方法 Method[] methodsAll = clazz.getDeclaredMethods(); for (Method m:methodsAll) &#123; //执行方法 run if(m.getName().equals(&quot;run&quot;)) &#123; m.setAccessible(true); m.invoke(car); &#125; &#125; &#125;&#125; 4.2、实现Spring的IoC我们知道，IoC（控制反转）和DI（依赖注入）是Spring里面核心的东西，那么，我们如何自己手写出这样的代码呢？下面我们就一步一步写出Spring框架最核心的部分。 ①搭建子模块 搭建模块：guigu-spring，搭建方式如其他spring子模块 ②准备测试需要的bean 添加依赖 12345678&lt;dependencies&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建UserDao接口 123456package com.atguigu.spring6.test.dao;public interface UserDao &#123; public void print();&#125; 创建UserDaoImpl实现 123456789101112package com.atguigu.spring6.test.dao.impl;import com.atguigu.spring.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 创建UserService接口 123456package com.atguigu.spring6.test.service;public interface UserService &#123; public void out();&#125; 创建UserServiceImpl实现类 1234567891011121314151617package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123;// private UserDao userDao; @Override public void out() &#123; //userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; ③定义注解 我们通过注解的形式加载bean与实现依赖注入 bean注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125; 依赖注入注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125; 说明：上面两个注解可以随意取名 ④定义bean容器接口 123456package com.atguigu.spring.core;public interface ApplicationContext &#123; Object getBean(Class clazz);&#125; ⑤编写注解bean容器接口实现 AnnotationApplicationContext基于注解扫描bean 12345678910111213141516171819202122package com.atguigu.spring.core;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; &#125;&#125; ⑥编写扫描bean逻辑 我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import java.io.File;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ⑦java类标识Bean注解 12@Beanpublic class UserServiceImpl implements UserService 12@Beanpublic class UserDaoImpl implements UserDao ⑧测试Bean加载 1234567891011121314151617package com.atguigu.spring;import com.atguigu.spring.core.AnnotationApplicationContext;import com.atguigu.spring.core.ApplicationContext;import com.atguigu.spring.test.service.UserService;import org.junit.jupiter.api.Test;public class SpringIocTest &#123; @Test public void testIoc() &#123; ApplicationContext applicationContext = new AnnotationApplicationContext(&quot;com.atguigu.spring.test&quot;); UserService userService = (UserService)applicationContext.getBean(UserService.class); userService.out(); System.out.println(&quot;run success&quot;); &#125;&#125; 控制台打印测试 ⑨依赖注入 只要userDao.print();调用成功，说明就注入成功 12345678910111213141516171819package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 执行第八步：报错了，说明当前userDao是个空对象 ⑩依赖注入实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import java.io.File;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; //依赖注入 loadDi(); &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; private void loadDi() &#123; for(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123; //就是咱们放在容器的对象 Object obj = entry.getValue(); Class&lt;?&gt; aClass = obj.getClass(); Field[] declaredFields = aClass.getDeclaredFields(); for (Field field : declaredFields)&#123; Di annotation = field.getAnnotation(Di.class); if( annotation != null )&#123; field.setAccessible(true); try &#123; System.out.println(&quot;正在给【&quot;+obj.getClass().getName()+&quot;】属性【&quot; + field.getName() + &quot;】注入值【&quot;+ beanFactory.get(field.getType()).getClass().getName() +&quot;】&quot;); field.set(obj,beanFactory.get(field.getType())); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 执行第八步：执行成功，依赖注入成功 5、面向切面：AOP5.1、场景模拟搭建子模块：spring6-aop 5.1.1、声明接口声明计算器接口Calculator，包含加减乘除的抽象方法 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 5.1.2、创建实现类 123456789101112131415161718192021222324252627282930313233343536373839404142public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.1.3、创建带日志功能的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 5.1.4、提出问题①现有代码缺陷 针对带日志功能的实现类，我们发现有如下缺陷： 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力 附加功能分散在各个业务功能方法中，不利于统一维护 ②解决思路 解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 ③困难 解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。 5.2、代理模式5.2.1、概念①介绍 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 使用代理后： ②生活中的代理 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。 5.2.2、静态代理创建静态代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult); return addResult; &#125;&#125; 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 5.2.3、动态代理 生产代理对象的工厂类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler); &#125;&#125; 5.2.4、测试1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 5.3、AOP概念及相关术语5.3.1、概述AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 5.3.2、相关术语①横切关注点分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ②通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ③切面封装通知方法的类。 ④目标被代理的目标对象。 ⑤代理向目标对象应用通知之后创建的代理对象。 ⑥连接点这也是一个纯逻辑概念，不是语法定义的。 把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方 ⑦切入点定位连接点的方式。 每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。 如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 5.3.3、作用 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。 5.4、基于注解的AOP5.4.1、技术说明 动态代理分为JDK动态代理和cglib动态代理 当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理 JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口 cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 5.4.2、准备工作①添加依赖 在IOC所需依赖基础上再加入下面依赖即可： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aspects依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ②准备被代理的目标资源 接口： 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Componentpublic class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.4.3、创建切面类并配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args); &#125; @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName); &#125; @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;) public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result); &#125; @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;) public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex); &#125; @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标对象（连接点）方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result; &#125; &#125; 在Spring的配置文件中配置： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 基于注解的AOP的实现： 1、将目标对象和切面交给IOC容器管理（注解+扫描） 2、开启AspectJ的自动代理，为目标对象自动生成代理 3、将切面类通过注解@Aspect标识 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 执行测试： 12345678910111213public class CalculatorTest &#123; private Logger logger = LoggerFactory.getLogger(CalculatorTest.class); @Test public void testAdd()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Calculator calculator = ac.getBean( Calculator.class); int add = calculator.add(1, 1); logger.info(&quot;执行成功:&quot;+add); &#125;&#125; 执行结果： 5.4.4、各种通知 前置通知：使用@Before注解标识，在被代理的目标方法前执行 返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命） 后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 各种通知的执行顺序： Spring版本5.3.x以前： 前置通知 目标操作 后置通知 返回通知或异常通知 Spring版本5.3.x以后： 前置通知 目标操作 返回通知或异常通知 后置通知 5.4.5、切入点表达式语法①作用 ②语法细节 用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限 在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。 例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello 在包名的部分，使用“*..”表示包名任意、包的层次深度任意 在类名的部分，类名部分整体用*号代替，表示类名任意 在类名的部分，可以使用*号代替类名的一部分 例如：*Service匹配所有名称以Service结尾的类或接口 在方法名部分，可以使用*号表示方法名任意 在方法名部分，可以使用*号代替方法名的一部分 例如：*Operation匹配所有方法名以Operation结尾的方法 在方法参数列表部分，使用(..)表示参数列表任意 在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头 在方法参数列表部分，基本数据类型和对应的包装类型是不一样的 切入点表达式中使用 int 和实际方法中 Integer 是不匹配的 在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符 例如：execution(public int ..Service.(.., int)) 正确 例如：execution( int *..Service.(.., int)) 错误 5.4.6、重用切入点表达式①声明 12@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125; ②在同一个切面中使用 123456@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ③在不同切面中使用 123456@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; 5.4.7、获取通知的相关信息①获取连接点信息 获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参 12345678@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; //获取连接点的签名信息 String methodName = joinPoint.getSignature().getName(); //获取目标方法到的实参信息 String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ②获取目标方法的返回值 @AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值 12345@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125; ③获取目标方法的异常 @AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常 12345@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125; 5.4.8、环绕通知123456789101112131415161718@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标方法的执行，目标方法的返回值一定要返回给外界调用者 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result;&#125; 5.4.9、切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用@Order注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 5.5、基于XML的AOP5.5.1、准备工作参考基于注解的AOP环境 5.5.2、实现1234567891011121314&lt;context:component-scan base-package=&quot;com.atguigu.aop.xml&quot;&gt;&lt;/context:component-scan&gt;&lt;aop:config&gt; &lt;!--配置切面类--&gt; &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.atguigu.aop.xml.CalculatorImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt; &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt; &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 6、单元测试：JUnit在之前的测试方法中，几乎都能看到以下的两行代码： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);Xxxx xxx = context.getBean(Xxxx.class); 这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了 6.1、整合JUnit56.1.1、搭建子模块搭建spring-junit模块 6.1.2、引入依赖1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 6.1.3、添加配置文件beans.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6.bean&quot;/&gt;&lt;/beans&gt; copy日志文件：log4j2.xml 6.1.4、添加java类1234567891011package com.atguigu.spring6.bean;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public User() &#123; System.out.println(&quot;run user&quot;); &#125;&#125; 6.1.5、测试123456789101112131415161718192021222324import com.atguigu.spring6.bean.User;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;//两种方式均可//方式一//@ExtendWith(SpringExtension.class)//@ContextConfiguration(&quot;classpath:beans.xml&quot;)//方式二@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class SpringJUnit5Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 6.2、整合JUnit4JUnit4在公司也会经常用到，在此也学习一下 6.2.1、添加依赖123456&lt;!-- junit测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 6.2.2、测试12345678910111213141516171819import com.atguigu.spring6.bean.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:beans.xml&quot;)public class SpringJUnit4Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 7、事务7.1、JdbcTemplate7.1.1、简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 7.1.2、准备工作①搭建子模块 搭建子模块：spring-jdbc-tx ②加入依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--spring jdbc Spring 持久化层支持jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ③创建jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=falsejdbc.driver=com.mysql.cj.jdbc.Driver ④配置Spring的配置文件 beans.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ⑤准备数据库与测试表 1234567891011CREATE DATABASE `spring`;use `spring`;CREATE TABLE `t_emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `sex` varchar(2) DEFAULT NULL COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 7.1.3、实现CURD①装配 JdbcTemplate创建测试类，整合JUnit，注入JdbcTemplate 12345678910111213package com.atguigu.spring6;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class JDBCTemplateTest &#123; @Autowired private JdbcTemplate jdbcTemplate; &#125; ②测试增删改功能123456789101112131415@Test//测试增删改功能public void testUpdate()&#123; //添加功能 String sql = &quot;insert into t_emp values(null,?,?,?)&quot;; int result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;); //修改功能 //String sql = &quot;update t_emp set name=? where id=?&quot;; //int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1); //删除功能 //String sql = &quot;delete from t_emp where id=?&quot;; //int result = jdbcTemplate.update(sql, 1);&#125; ③查询数据返回对象1234567891011121314151617181920public class Emp &#123; private Integer id; private String name; private Integer age; private String sex; //生成get和set方法 //...... @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122//查询：返回对象@Testpublic void testSelectObject() &#123; //写法一// String sql = &quot;select * from t_emp where id=?&quot;;// Emp empResult = jdbcTemplate.queryForObject(sql,// (rs, rowNum) -&gt; &#123;// Emp emp = new Emp();// emp.setId(rs.getInt(&quot;id&quot;));// emp.setName(rs.getString(&quot;name&quot;));// emp.setAge(rs.getInt(&quot;age&quot;));// emp.setSex(rs.getString(&quot;sex&quot;));// return emp;// &#125;, 1);// System.out.println(empResult); //写法二 String sql = &quot;select * from t_emp where id=?&quot;; Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class),1); System.out.println(emp);&#125; ④查询数据返回list集合1234567@Test//查询多条数据为一个list集合public void testSelectList()&#123; String sql = &quot;select * from t_emp&quot;; List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class)); System.out.println(list);&#125; ⑤查询返回单个的值1234567@Test//查询单行单列的值public void selectCount()&#123; String sql = &quot;select count(id) from t_emp&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count);&#125; 7.2、声明式事务概念7.2.1、事务基本概念①什么是事务数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 ②事务的特性A：原子性(Atomicity) 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C：一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。 如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。 如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。 I：隔离性(Isolation) 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。 D：持久性(Durability) 指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 7.2.2、编程式事务事务功能的相关操作全部通过自己编写代码来实现： 1234567891011121314151617181920212223Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 7.2.3、声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 好处1：提高开发效率 好处2：消除了冗余的代码 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化 所以，我们可以总结下面两个概念： 编程式：自己写代码实现功能 声明式：通过配置让框架实现功能 7.3、基于注解的声明式事务7.3.1、准备工作①添加配置 在beans.xml添加配置 12&lt;!--扫描组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; ②创建表 123456789101112131415CREATE TABLE `t_book` ( `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;, `stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); ③创建组件 创建BookController： 123456789101112package com.atguigu.spring6.controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; public void buyBook(Integer bookId, Integer userId)&#123; bookService.buyBook(bookId, userId); &#125;&#125; 创建接口BookService： 1234package com.atguigu.spring6.service;public interface BookService &#123; void buyBook(Integer bookId, Integer userId);&#125; 创建实现类BookServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; @Override public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); &#125;&#125; 创建接口BookDao： 12345678package com.atguigu.spring6.dao;public interface BookDao &#123; Integer getPriceByBookId(Integer bookId); void updateStock(Integer bookId); void updateBalance(Integer userId, Integer price);&#125; 创建实现类BookDaoImpl： 12345678910111213141516171819202122232425package com.atguigu.spring6.dao.impl;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId(Integer bookId) &#123; String sql = &quot;select price from t_book where book_id = ?&quot;; return jdbcTemplate.queryForObject(sql, Integer.class, bookId); &#125; @Override public void updateStock(Integer bookId) &#123; String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;; jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId, Integer price) &#123; String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;; jdbcTemplate.update(sql, price, userId); &#125;&#125; 7.3.2、测试无事务情况①创建测试类 1234567891011121314151617import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1, 1); &#125;&#125; ②模拟场景 用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额 假设用户id为1的用户，购买id为1的图书 用户余额为50，而图书价格为80 购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段 此时执行sql语句会抛出SQLException ③观察结果 因为没有添加事务，图书的库存更新了，但是用户的余额没有更新 显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败 7.3.3、加入事务①添加事务配置在spring配置文件中引入tx命名空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 在Spring的配置文件中添加配置： 12345678910&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启事务的注解驱动 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; ②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解@Transactional ③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行 7.3.4、@Transactional注解标识的位置@Transactional标识在方法上，则只会影响该方法 @Transactional标识的类上，则会影响类中所有的方法 7.3.5、事务属性：只读①介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 ②使用方式 12345678910@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③注意 对增删改操作设置只读会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed 7.3.6、事务属性：超时①介绍 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 ②使用方式 12345678910111213141516//超时时间单位秒@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③观察结果 执行过程中抛出异常： org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022 7.3.7、事务属性：回滚策略①介绍 声明式事务默认只针对运行时异常回滚，编译时异常不回滚。 可以通过@Transactional中相关属性设置回滚策略 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 noRollbackFor属性：需要设置一个Class类型的对象 rollbackFor属性：需要设置一个字符串类型的全类名 ②使用方式 1234567891011@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); System.out.println(1/0);&#125; ③观察结果 虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行 7.3.8、事务属性：隔离级别①介绍 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 隔离级别一共有四种： 读未提交：READ UNCOMMITTED 允许Transaction01读取Transaction02未提交的修改。 读已提交：READ COMMITTED、 要求Transaction01只能读取Transaction02已提交的修改。 可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 有 有 有 READ COMMITTED 无 有 有 REPEATABLE READ 无 无 有 SERIALIZABLE 无 无 无 各种数据库产品对事务隔离级别的支持程度： 隔离级别 Oracle MySQL READ UNCOMMITTED × √ READ COMMITTED √(默认) √ REPEATABLE READ × √(默认) SERIALIZABLE √ √ ②使用方式 12345@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化 7.3.9、事务属性：传播行为①介绍 什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 一共有七种传播行为： REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】 MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】 REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】 NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】 NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】 NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】 ②测试 创建接口CheckoutService： 12345package com.atguigu.spring6.service;public interface CheckoutService &#123; void checkout(Integer[] bookIds, Integer userId);&#125; 创建实现类CheckoutServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //一次购买多本图书 public void checkout(Integer[] bookIds, Integer userId) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(bookId, userId); &#125; &#125;&#125; 在BookController中添加方法： 123456@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer[] bookIds, Integer userId)&#123; checkoutService.checkout(bookIds, userId);&#125; 在数据库中将用户的余额修改为100元 ③观察结果 可以通过@Transactional中的propagation属性设置事务传播行为 修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性 @Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了 @Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。 7.3.10、全注解配置事务①添加配置类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@Configuration@ComponentScan(&quot;com.atguigu.spring6&quot;)@EnableTransactionManagementpublic class SpringConfig &#123; @Bean public DataSource getDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean(name = &quot;jdbcTemplate&quot;) public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125; ②测试 1234567891011121314151617import com.atguigu.spring6.config.SpringConfig;import com.atguigu.spring6.controller.BookController;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;public class TxByAllAnnotationTest &#123; @Test public void testTxAllAnnotation()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); BookController accountService = applicationContext.getBean(&quot;bookController&quot;, BookController.class); accountService.buyBook(1, 1); &#125;&#125; 7.4、基于XML的声明式事务7.3.1、场景模拟参考基于注解的声明式事务 7.3.2、修改Spring配置文件将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置： 1234567891011121314151617181920212223242526&lt;aop:config&gt; &lt;!-- 配置事务通知和切入点表达式 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.atguigu.spring.tx.xml.service.impl.*.*(..))&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt;&lt;!-- tx:advice标签：配置事务通知 --&gt;&lt;!-- id属性：给事务通知标签设置唯一标识，便于引用 --&gt;&lt;!-- transaction-manager属性：关联事务管理器 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- tx:method标签：配置具体的事务方法 --&gt; &lt;!-- name属性：指定方法名，可以使用星号代表多个字符 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;!-- read-only属性：设置只读属性 --&gt; &lt;!-- rollback-for属性：设置回滚的异常 --&gt; &lt;!-- no-rollback-for属性：设置不回滚的异常 --&gt; &lt;!-- isolation属性：设置事务的隔离级别 --&gt; &lt;!-- timeout属性：设置事务的超时属性 --&gt; &lt;!-- propagation属性：设置事务的传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;update*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 注意：基于xml实现的声明式事务，必须引入aspectJ的依赖 12345 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt;&lt;/dependency&gt; 8、资源操作：Resources8.1、Spring Resources概述 Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。而Spring的Resource声明了访问low-level资源的能力。 8.2、Resource接口Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法 12345678910111213141516171819202122232425262728public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); boolean isFile(); URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; ReadableByteChannel readableChannel() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法： 12345public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; 其中一些重要的方法： getInputStream(): 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流exists(): 返回一个布尔值，表明某个资源是否以物理形式存在isOpen: 返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。getDescription(): 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。 其他方法： isReadable(): 表明资源的目录读取是否通过getInputStream()进行读取。isFile(): 表明这个资源是否代表了一个文件系统的文件。getURL(): 返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOExceptiongetURI(): 返回一个资源的URI句柄getFile(): 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundExceptionlastModified(): 资源最后一次修改的时间戳createRelative(): 创建此资源的相关资源getFilename(): 资源的文件名是什么 例如：最后一部分的文件名 myfile.txt 8.3、Resource的实现类Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource 8.3.1、UrlResource访问网络资源Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。 http:——该前缀用于访问基于HTTP协议的网络资源。 ftp:——该前缀用于访问基于FTP协议的网络资源 file: ——该前缀用于从文件系统中读取资源 实验：访问基于HTTP协议的网络资源 创建一个maven子模块spring6-resources，配置Spring依赖（参考前面） 12345678910111213141516171819202122232425262728package com.atguigu.spring6.resources;import org.springframework.core.io.UrlResource;public class UrlResourceDemo &#123; public static void loadAndReadUrlResource(String path)&#123; // 创建一个 Resource 对象 UrlResource url = null; try &#123; url = new UrlResource(path); // 获取资源名 System.out.println(url.getFilename()); System.out.println(url.getURI()); // 获取资源描述 System.out.println(url.getDescription()); //获取资源内容 System.out.println(url.getInputStream().read()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; //访问网络资源 loadAndReadUrlResource(&quot;http://www.baidu.com&quot;); &#125;&#125; 实验二：在项目根路径下创建文件，从文件系统中读取资源 方法不变，修改调用传递路径 1234567public static void main(String[] args) &#123; //1 访问网络资源 //loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;); //2 访问文件系统资源 loadAndReadUrlResource(&quot;file:atguigu.txt&quot;);&#125; 8.3.2、ClassPathResource 访问类路径下资源ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。 实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问 1234567891011121314151617181920212223242526package com.atguigu.spring6.resources;import org.springframework.core.io.ClassPathResource;import java.io.InputStream;public class ClassPathResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; // 创建一个 Resource 对象 ClassPathResource resource = new ClassPathResource(path); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。 8.3.3、FileSystemResource 访问文件系统资源Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。 实验：使用FileSystemResource 访问文件系统资源 1234567891011121314151617181920212223242526272829package com.atguigu.spring6.resources;import org.springframework.core.io.FileSystemResource;import java.io.InputStream;public class FileSystemResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; //相对路径 FileSystemResource resource = new FileSystemResource(&quot;atguigu.txt&quot;); //绝对路径 //FileSystemResource resource = new FileSystemResource(&quot;C:\\\\atguigu.txt&quot;); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。 8.3.4、ServletContextResource这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。 8.3.5、InputStreamResourceInputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。 8.3.6、ByteArrayResource字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。 8.4、Resource类图上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示 8.5、ResourceLoader 接口8.5.1、ResourceLoader 概述Spring 提供如下两个标志性接口： （1）ResourceLoader ： 该接口实现类的实例可以获得一个Resource实例。 （2） ResourceLoaderAware ： 该接口实现类的实例将获得一个ResourceLoader的引用。 在ResourceLoader接口里有如下方法： （1）Resource getResource（String location） ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。 8.5.2、使用演示实验一：ClassPathXmlApplicationContext获取Resource实例 1234567891011121314151617package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext();// 通过ApplicationContext访问资源// ApplicationContext实例获取Resource实例时，// 默认采用与ApplicationContext相同的资源访问策略 Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 实验二：FileSystemApplicationContext获取Resource实例 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new FileSystemXmlApplicationContext(); Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 8.5.3、ResourceLoader 总结Spring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例 当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来 另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类 123Resource res = ctx.getResource(&quot;calsspath:bean.xml&quot;);Resrouce res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;http://localhost:8080/beans.xml&quot;); 8.6、ResourceLoaderAware 接口ResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。 如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。 实验：演示ResourceLoaderAware使用 第一步 创建类，实现ResourceLoaderAware接口 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.ResourceLoader;public class TestBean implements ResourceLoaderAware &#123; private ResourceLoader resourceLoader; //实现ResourceLoaderAware接口必须实现的方法 //如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。 //SPring容器调用该方法时，Spring会将自身作为参数传给该方法。 public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; //返回ResourceLoader对象的应用 public ResourceLoader getResourceLoader()&#123; return this.resourceLoader; &#125;&#125; 第二步 创建bean.xml文件，配置TestBean 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testBean&quot; class=&quot;com.atguigu.spring6.resouceloader.TestBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步 测试 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;public class Demo3 &#123; public static void main(String[] args) &#123; //Spring容器会将一个ResourceLoader对象作为该方法的参数传入 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); TestBean testBean = ctx.getBean(&quot;testBean&quot;,TestBean.class); //获取ResourceLoader对象 ResourceLoader resourceLoader = testBean.getResourceLoader(); System.out.println(&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot; + (resourceLoader == ctx)); //加载其他资源 Resource resource = resourceLoader.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 8.7、使用Resource 作为属性前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。 归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案： 代码中获取 Resource 实例。 使用依赖注入。 对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。 实验：让Spring为Bean实例依赖注入资源 第一步 创建依赖注入类，定义属性和方法 1234567891011121314151617181920package com.atguigu.spring6.resouceloader;import org.springframework.core.io.Resource;public class ResourceBean &#123; private Resource res; public void setRes(Resource res) &#123; this.res = res; &#125; public Resource getRes() &#123; return res; &#125; public void parse()&#123; System.out.println(res.getFilename()); System.out.println(res.getDescription()); &#125;&#125; 第二步 创建spring配置文件，配置依赖注入 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;resourceBean&quot; class=&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot; &gt; &lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt; &lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt; &lt;property name=&quot;res&quot; value=&quot;classpath:atguigu.txt&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 测试 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Demo4 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ResourceBean resourceBean = ctx.getBean(&quot;resourceBean&quot;,ResourceBean.class); resourceBean.parse(); &#125;&#125; 8.8、应用程序上下文和资源路径8.8.1、概述不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。 ApplicationContext确定资源访问策略通常有两种方法： （1）使用ApplicationContext实现类指定访问策略。 （2）使用前缀指定访问策略。 8.8.2、ApplicationContext实现类指定访问策略创建ApplicationContext对象时，通常可以使用如下实现类： （1） ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。 （2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。 （3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。 当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。 效果前面已经演示 8.8.3、使用前缀指定访问策略实验一：classpath前缀使用 12345678910111213141516171819202122package com.atguigu.spring6.context;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; /* * 通过搜索文件系统路径下的xml文件创建ApplicationContext， * 但通过指定classpath:前缀强制搜索类加载路径 * classpath:bean.xml * */ ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean.xml&quot;); System.out.println(ctx); Resource resource = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 实验二：classpath通配符使用 classpath * :前缀提供了加载多个XML配置文件的能力，当使用classpath*:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。 12ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean.xml&quot;);System.out.println(ctx); 当使用classpath * :前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。 如果不是采用classpath * :前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件 注意 ： classpath * : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath * :前缀不可用于Resource。 使用三：通配符其他使用 一次性加载多个配置文件的方式：指定配置文件时使用通配符 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean*.xml&quot;); Spring允许将classpath*:前缀和通配符结合使用： 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean*.xml&quot;); 9、国际化：i18n 9.1、i18n概述国际化也称作i18n，其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数。由于软件发行可能面向多个国家，对于不同国家的用户，软件显示不同语言的过程就是国际化。通常来讲，软件中的国际化是通过配置文件来实现的，假设要支撑两种语言，那么就需要两个版本的配置文件。 9.2、Java国际化（1）Java自身是支持国际化的，java.util.Locale用于指定当前用户所属的语言环境等信息，java.util.ResourceBundle用于查找绑定对应的资源文件。Locale包含了language信息和country信息，Locale创建默认locale对象时使用的静态方法： 12345678/** * This method must be called only for creating the Locale.* * constants due to making shortcuts. */private static Locale createConstant(String lang, String country) &#123; BaseLocale base = BaseLocale.createInstance(lang, country); return getInstance(base, null);&#125; （2）配置文件命名规则： basename_language_country.properties 必须遵循以上的命名规则，java才会识别。其中，basename是必须的，语言和国家是可选的。这里存在一个优先级概念，如果同时提供了messages.properties和messages_zh_CN.propertes两个配置文件，如果提供的locale符合en_CN，那么优先查找messages_en_CN.propertes配置文件，如果没查找到，再查找messages.properties配置文件。最后，提示下，所有的配置文件必须放在classpath中，一般放在resources目录下 （3）实验：演示Java国际化 第一步 创建子模块spring6-i18n，引入spring依赖 第二步 在resource目录下创建两个配置文件：messages_zh_CN.propertes和messages_en_GB.propertes 第三步 测试 12345678910111213141516package com.atguigu.spring6.javai18n;import java.nio.charset.StandardCharsets;import java.util.Locale;import java.util.ResourceBundle;public class Demo1 &#123; public static void main(String[] args) &#123; System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;en&quot;,&quot;GB&quot;)).getString(&quot;test&quot;)); System.out.println(ResourceBundle.getBundle(&quot;messages&quot;, new Locale(&quot;zh&quot;,&quot;CN&quot;)).getString(&quot;test&quot;)); &#125;&#125; 9.3、Spring6国际化9.3.1、MessageSource接口spring中国际化是通过MessageSource这个接口来支持的 常见实现类 ResourceBundleMessageSource 这个是基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源 ReloadableResourceBundleMessageSource 这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息 StaticMessageSource 它允许通过编程的方式提供国际化信息，一会我们可以通过这个来实现db中存储国际化信息的功能。 9.3.2、使用Spring6国际化第一步 创建资源文件 国际化文件命名格式：基本名称 _ 语言 _ 国家.properties {0},{1}这样内容，就是动态参数 （1）创建atguigu_en_US.properties 1www.atguigu.com=welcome &#123;0&#125;,时间:&#123;1&#125; （2）创建atguigu_zh_CN.properties 1www.atguigu.com=欢迎 &#123;0&#125;,时间:&#123;1&#125; 第二步 创建spring配置文件，配置MessageSource 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot;&gt; &lt;list&gt; &lt;value&gt;atguigu&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;utf-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 创建测试类 1234567891011121314151617181920212223package com.atguigu.spring6.javai18n;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Date;import java.util.Locale;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //传递动态参数，使用数组形式对应&#123;0&#125; &#123;1&#125;顺序 Object[] objs = new Object[]&#123;&quot;atguigu&quot;,new Date().toString()&#125;; //www.atguigu.com为资源文件的key值, //objs为资源文件value值所需要的参数,Local.CHINA为国际化为语言 String str=context.getMessage(&quot;www.atguigu.com&quot;, objs, Locale.CHINA); System.out.println(str); &#125;&#125; 10、数据校验：Validation 10.1、Spring Validation概述 在开发中，我们经常遇到参数校验的需求，比如用户注册的时候，要校验用户名不能为空、用户名长度不超过20个字符、手机号是合法的手机号格式等等。如果使用普通方式，我们会把校验的代码和真正的业务处理逻辑耦合在一起，而且如果未来要新增一种校验逻辑也需要在修改多个地方。而spring validation允许通过注解的方式来定义对象校验规则，把校验和业务逻辑分离开，让代码编写更加方便。Spring Validation其实就是对Hibernate Validator进一步的封装，方便在Spring中使用。 在Spring中有多种校验的方式 第一种是通过实现org.springframework.validation.Validator接口，然后在代码中调用这个类 第二种是按照Bean Validation方式来进行校验，即通过注解的方式。 第三种是基于方法实现校验 除此之外，还可以实现自定义校验 10.2、实验一：通过Validator接口实现第一步 创建子模块 spring6-validator 第二步 引入相关依赖 12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;7.0.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish&lt;/groupId&gt; &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步 创建实体类，定义属性和方法 12345678910111213141516171819package com.atguigu.spring6.validation.method1;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 第四步 创建类实现Validator接口，实现接口方法指定校验规则 123456789101112131415161718192021222324package com.atguigu.spring6.validation.method1;import org.springframework.validation.Errors;import org.springframework.validation.ValidationUtils;import org.springframework.validation.Validator;public class PersonValidator implements Validator &#123; @Override public boolean supports(Class&lt;?&gt; clazz) &#123; return Person.class.equals(clazz); &#125; @Override public void validate(Object object, Errors errors) &#123; ValidationUtils.rejectIfEmpty(errors, &quot;name&quot;, &quot;name.empty&quot;); Person p = (Person) object; if (p.getAge() &lt; 0) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value &lt; 0&quot;); &#125; else if (p.getAge() &gt; 110) &#123; errors.rejectValue(&quot;age&quot;, &quot;error value too old&quot;); &#125; &#125;&#125; 上面定义的类，其实就是实现接口中对应的方法， supports方法用来表示此校验用在哪个类型上， validate是设置校验逻辑的地点，其中ValidationUtils，是Spring封装的校验工具类，帮助快速实现校验。 第五步 使用上述Validator进行测试 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method1;import org.springframework.validation.BindingResult;import org.springframework.validation.DataBinder;public class TestMethod1 &#123; public static void main(String[] args) &#123; //创建person对象 Person person = new Person(); person.setName(&quot;lucy&quot;); person.setAge(-1); // 创建Person对应的DataBinder DataBinder binder = new DataBinder(person); // 设置校验 binder.setValidator(new PersonValidator()); // 由于Person对象中的属性为空，所以校验不通过 binder.validate(); //输出结果 BindingResult results = binder.getBindingResult(); System.out.println(results.getAllErrors()); &#125;&#125; 10.3、实验二：Bean Validation注解实现使用Bean Validation校验方式，就是如何将Bean Validation需要使用的javax.validation.ValidatorFactory 和javax.validation.Validator注入到容器中。spring默认有一个实现类LocalValidatorFactoryBean，它实现了上面Bean Validation中的接口，并且也实现了org.springframework.validation.Validator接口。 第一步 创建配置类，配置LocalValidatorFactoryBean 123456789@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method2&quot;)public class ValidationConfig &#123; @Bean public LocalValidatorFactoryBean validator() &#123; return new LocalValidatorFactoryBean(); &#125;&#125; 第二步 创建实体类，使用注解定义校验规则 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method2;import jakarta.validation.constraints.Max;import jakarta.validation.constraints.Min;import jakarta.validation.constraints.NotNull;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 常用注解说明@NotNull 限制必须不为null@NotEmpty 只作用于字符串类型，字符串不为空，并且长度不为0@NotBlank 只作用于字符串类型，字符串不为空，并且trim()后不为空串@DecimalMax(value) 限制必须为一个不大于指定值的数字@DecimalMin(value) 限制必须为一个不小于指定值的数字@Max(value) 限制必须为一个不大于指定值的数字@Min(value) 限制必须为一个不小于指定值的数字@Pattern(value) 限制必须符合指定的正则表达式@Size(max,min) 限制字符长度必须在min到max之间@Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 第三步 使用两种不同的校验器实现 （1）使用jakarta.validation.Validator校验 1234567891011121314151617181920package com.atguigu.spring6.validation.method2;import jakarta.validation.ConstraintViolation;import jakarta.validation.Validator;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.Set;@Servicepublic class MyService1 &#123; @Autowired private Validator validator; public boolean validator(User user)&#123; Set&lt;ConstraintViolation&lt;User&gt;&gt; sets = validator.validate(user); return sets.isEmpty(); &#125;&#125; （2）使用org.springframework.validation.Validator校验 12345678910111213141516171819package com.atguigu.spring6.validation.method2;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.validation.BindException;import org.springframework.validation.Validator;@Servicepublic class MyService2 &#123; @Autowired private Validator validator; public boolean validaPersonByValidator(User user) &#123; BindException bindException = new BindException(user, user.getName()); validator.validate(user, bindException); return bindException.hasErrors(); &#125;&#125; 第四步 测试 123456789101112131415161718192021222324252627282930package com.atguigu.spring6.validation.method2;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod2 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService1 myService = context.getBean(MyService1.class); User user = new User(); user.setAge(-1); boolean validator = myService.validator(user); System.out.println(validator); &#125; @Test public void testMyService2() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService2 myService = context.getBean(MyService2.class); User user = new User(); user.setName(&quot;lucy&quot;); user.setAge(130); user.setAge(-1); boolean validator = myService.validaPersonByValidator(user); System.out.println(validator); &#125;&#125; 10.4、实验三：基于方法实现校验第一步 创建配置类，配置MethodValidationPostProcessor 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;@Configuration@ComponentScan(&quot;com.atguigu.spring6.validation.method3&quot;)public class ValidationConfig &#123; @Bean public MethodValidationPostProcessor validationPostProcessor() &#123; return new MethodValidationPostProcessor(); &#125;&#125; 第二步 创建实体类，使用注解设置校验规则 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring6.validation.method3;import jakarta.validation.constraints.*;public class User &#123; @NotNull private String name; @Min(0) @Max(120) private int age; @Pattern(regexp = &quot;^1(3|4|5|7|8)\\\\d&#123;9&#125;$&quot;,message = &quot;手机号码格式错误&quot;) @NotBlank(message = &quot;手机号码不能为空&quot;) private String phone; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125;&#125; 第三步 定义Service类，通过注解操作对象 12345678910111213141516package com.atguigu.spring6.validation.method3;import jakarta.validation.Valid;import jakarta.validation.constraints.NotNull;import org.springframework.stereotype.Service;import org.springframework.validation.annotation.Validated;@Service@Validatedpublic class MyService &#123; public String testParams(@NotNull @Valid User user) &#123; return user.toString(); &#125;&#125; 第四步 测试 1234567891011121314151617package com.atguigu.spring6.validation.method3;import org.junit.jupiter.api.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TestMethod3 &#123; @Test public void testMyService1() &#123; ApplicationContext context = new AnnotationConfigApplicationContext(ValidationConfig.class); MyService myService = context.getBean(MyService.class); User user = new User(); user.setAge(-1); myService.testParams(user); &#125;&#125; 10.5、实验四：实现自定义校验第一步 自定义校验注解 12345678910111213141516171819202122232425262728package com.atguigu.spring6.validation.method4;import jakarta.validation.Constraint;import jakarta.validation.Payload;import java.lang.annotation.*;@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validatedBy = &#123;CannotBlankValidator.class&#125;)public @interface CannotBlank &#123; //默认错误消息 String message() default &quot;不能包含空格&quot;; //分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;) @Retention(RetentionPolicy.RUNTIME) @Documented @interface List &#123; CannotBlank[] value(); &#125;&#125; 第二步 编写真正的校验类 123456789101112131415161718192021222324252627package com.atguigu.spring6.validation.method4;import jakarta.validation.ConstraintValidator;import jakarta.validation.ConstraintValidatorContext;public class CannotBlankValidator implements ConstraintValidator&lt;CannotBlank, String&gt; &#123; @Override public void initialize(CannotBlank constraintAnnotation) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;).addConstraintViolation(); return false; &#125; return true; &#125;&#125; 11、提前编译：AOT 11.1、AOT概述11.1.1、JIT与AOT的区别JIT和AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译 （1）JIT， Just-in-time,动态(即时)编译，边运行边编译； 在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。 （2）AOT，Ahead Of Time，指运行前编译，预先编译。 AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。 简单来讲：JIT即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 1.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据） （3）AOT的优点 简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能，程序启动速度快运行产物只有机器码，打包体积小 AOT的缺点 由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行 第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。 现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。 11.1.2、GraalvmSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 GraalVM 具有以下特性： （1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源 （2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能 （3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销 （4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗 总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。 11.1.3、Native Image目前业界除了这种在JVM中进行AOT的方案，还有另外一种实现Java AOT的思路，那就是直接摒弃JVM，和C/C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆Java语言设计的思路，那就是GraalVM Native Image。它通过C语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了JVM的各种特性，但足够轻量、可以被轻松内嵌，这就让Java语言和工程摆脱JVM的限制，能够真正意义上实现和C/C++一样的AOT编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为Oracle官方首推的Java AOT解决方案。Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。 11.2、演示Native Image构建过程11.2.1、GraalVM安装（1）下载GraalVM进入官网下载：https://www.graalvm.org/downloads/ （2）配置环境变量添加GRAALVM_HOME 把JAVA_HOME修改为graalvm的位置 把Path修改位graalvm的bin位置 使用命令查看是否安装成功 （3）安装native-image插件使用命令 gu install native-image下载安装 11.2.2、安装C++的编译环境（1）下载Visual Studio安装软件https://visualstudio.microsoft.com/zh-hans/downloads/ （2）安装Visual Studio （3）添加Visual Studio环境变量配置INCLUDE、LIB和Path （4）打开工具，在工具中操作 11.2.3、编写代码，构建Native Image（1）编写Java代码123456public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125;&#125; （2）复制文件到目录，执行编译 （3）Native Image 进行构建 （4）查看构建的文件 （5）执行构建的文件 可以看到这个Hello最终打包产出的二进制文件大小为11M，这是包含了SVM和JDK各种库后的大小，虽然相比C/C++的二进制文件来说体积偏大，但是对比完整JVM来说，可以说是已经是非常小了。 相比于使用JVM运行，Native Image的速度要快上不少，cpu占用也更低一些，从官方提供的各类实验数据也可以看出Native Image对于启动速度和内存占用带来的提升是非常显著的：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://coder-xbai.github.io/categories/JAVA/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://coder-xbai.github.io/tags/Spring%E6%A1%86%E6%9E%B6/"}]},{"title":"mysql-2","slug":"mysql-2","date":"2023-06-28T02:31:32.000Z","updated":"2023-07-08T09:17:21.416Z","comments":true,"path":"2023/06/28/mysql-2.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/28/mysql-2.html","excerpt":"","text":"1，远程连接Linux下的MySQL确认网络没有问题 在远程机器上使用ping ip地址 保证网络畅通 在远程机器上使用telnet命令 保证端口号开放 访问 telnet ip地址 端口号 启动windows下的Telnet 关闭防火墙 systemctl stop firewalld.service 修改MySQL下的ip访问限制 （让所有ip都能访问）生产环境下禁止这种情况，要根据安全规则进行配置ip 123update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;flush privileges; ###2，mysql5.7或之前版本中字符编码问题 Linux下的mysql5.7字符编码默认使用’latin1’，在新建库，表时导致无法插入中文。 123show variables like &#x27;character%&#x27;;# 或者show variables like &#x27;%char%&#x27;; 解决方法，一步到位 vim /etc/my.cnf character_set_server=utf8 systemctl restart mysqld 不会影响之前已建库，表，需要手动更改 123alter database dbtest1 character set &#x27;utf8&#x27;;alter table t_emp convert to character set &#x27;utf8&#x27;; 用户和权限管理DESCRIBE ‘表名’; 查看某个表基本结构 引入角色的目的是方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的。 创建角色使用 CREATE ROLE 语句，语法如下： 1CREATE ROLE &#x27;role_name&#x27;[@&#x27;host_name&#x27;] [,&#x27;role_name&#x27;[@&#x27;host_name&#x27;]]... 角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为空。 练习：我们现在需要创建一个经理的角色，就可以用下面的代码： 1CREATE ROLE &#x27;manager&#x27;@&#x27;localhost&#x27;; ​ 给角色赋予权限创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是： 1GRANT privileges ON table_name TO &#x27;role_name&#x27;[@&#x27;host_name&#x27;]; 上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，列出了部分权限列表。 1SHOW PRIVILEGES\\G MySQL索引的数据结构​ 内容比较难和复杂，这里引用了尚硅谷-宋红康老师文档，可以仔细阅读！ 尚硅谷-宋红康","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MySql中高级查漏补缺","slug":"MySql中高级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E4%B8%AD%E9%AB%98%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"mysql_1","slug":"mysql-1","date":"2023-06-27T02:25:15.000Z","updated":"2023-07-08T09:17:10.513Z","comments":true,"path":"2023/06/27/mysql-1.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/27/mysql-1.html","excerpt":"","text":"MySql初级查漏补缺1，支持的json类型​ 从mysql5.7开始支持，到8.x版本时JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使用更方便。 123456789101112131415161718CREATE DATABASE IF NOT EXISTS test01_office CHARACTER SET &#x27;utf8&#x27;;USE test01_officeCREATE TABLE test_json(js json);-- json 类型 &#x27;&#123;&quot;KEY1&quot;:&quot;value1&quot;,&quot;KEY2&quot;:&quot;value2&quot; &#125;&#x27;INSERT INTO test_json (js)VALUES ( &#x27;&#123;&quot;KEY&quot;:&quot;value&quot;,&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;)SELECT * FROM test_json; 2，使用时间类型选择​ 在多数开发过程中，都是选择 DATETIME 类型，包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。 但是如果是记录注册时间或商品发布时间等。使用_TIMESTAMP(时间戳)更方便计算。 3，主键自增一个小知识 —自增变量的持久化​ 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 ​ 从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。 删除id为5的记录，结果如下： ​ 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。 ​ 在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： 从结果可以看出，自增变量已经持久化了。 ​ MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。 4，存储过程创建存储过程格式12345CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END ​ 说明：INOUT ：当前参数既可以为输入参数，也可以为输出参数。 ​ 类似于Java中的方法： 1234修饰符 返回类型 方法名(参数类型 参数名,...)&#123;方法体;&#125; ​ 例子: 123456789DELIMITER //CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGINSELECT COUNT(*) INTO num FROM fruitsWHERE s_id = sid;END //DELIMITER ; 调用存储过程及查看返回结果123456mysql&gt; CALL CountProc (101, @num);Query OK, 1 row affected (0.00 sec)-- 查看返回结果mysql&gt; SELECT @num; 5，变量、流程控制与游标的重要知识变量​ 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。 1234567#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;或SHOW VARIABLES; ​ 用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。 ​ 会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。​ 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。 1234567#方式1：“=”或“:=”SET @用户变量 = 值;SET @用户变量 := 值;#方式2：“:=” 或 INTO关键字SELECT @用户变量 := 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句]; 查看用户变量的值 （查看、比较、运算等） 1234567SELECT @用户变量SELECT @a;SELECT @num := COUNT(*) FROM employees;SELECT @num;SELECT AVG(salary) INTO @avgsalary FROM employees;SELECT @avgsalary;SELECT @big; #查看某个未声明的变量时，将得到NULL值 局部变量 123DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULLDECLARE myparam INT DEFAULT 100; 6，流程控制分支12345IF 表达式1 THEN 操作1[ELSEIF 表达式2 THEN 操作2]……[ELSE 操作N]END IF 例子：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。 1234567891011DELIMITER //CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_yearFROM employees WHERE employee_id = emp_id;IF emp_salary &lt; 8000 AND hire_year &gt; 5THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;END IF;END //DELIMITER ; 分支结构之 CASE1234567#情况一：类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要） 例3：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。 12345678910111213141516DELIMITER //BEGINDECLARE emp_sal DOUBLE;DECLARE bonus DECIMAL(3,2);SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;CASEWHEN emp_sal&lt;9000THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;WHEN emp_sal&lt;10000 AND bonus IS NULLTHEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;ELSEUPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;END CASE;END //DELIMITER ; 循环结构之LOOP使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。 1234567DECLARE id INT DEFAULT 0;add_loop:LOOPSET id = id +1;IF id &gt;= 10 THEN LEAVE add_loop;END IF;END LOOP add_loop; 循环结构之WHILE和REPEATWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下： 例子：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。 123456789101112131415DELIMITER //CREATE PROCEDURE update_salary_while(OUT num INT)BEGINDECLARE avg_sal DOUBLE ;DECLARE while_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_sal FROM employees;WHILE avg_sal &gt; 5000 DOUPDATE employees SET salary = salary * 0.9;SET while_count = while_count + 1;SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;SET num = while_count;END //DELIMITER ; REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。 1234567891011DELIMITER //CREATE PROCEDURE test_repeat()BEGINDECLARE i INT DEFAULT 0;REPEATSET i = i + 1;UNTIL i &gt;= 10END REPEAT;SELECT i;END //DELIMITER ; 跳转语句之LEAVE语句 (类似于 java中的break)，跳转语句之ITERATE语句（类似于 java中的continue） 具体解释省略 7，游标​ 定义：在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。 游标的使用过程： 第一步，声明游标()； 1DECLARE cur_emp CURSOR FOR 第二步，打开游标(OPEN cursor_name)； 1OPEN cursor_name 第三步使用游标（从游标中取得数据）()； 1FETCH cursor_name INTO var_name [, var_name] ... 第四步，关闭游标 1CLOSE cursor_name ​ 例子：创建存储过程“get_count_by_limit_total_salary()”，声明IN参limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。 123456789101112131415161718192021222324DELIMITER //CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUTtotal_count INT)BEGINDECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值DECLARE emp_count INT DEFAULT 0; #记录循环个数#定义游标DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;#打开游标OPEN emp_cursor;REPEAT#使用游标（从游标中获取数据）FETCH emp_cursor INTO cursor_salary;SET sum_salary = sum_salary + cursor_salary;SET emp_count = emp_count + 1;UNTIL sum_salary &gt;= limit_total_salaryEND REPEAT;SET total_count = emp_count;#关闭游标CLOSE emp_cursor;END //DELIMITER ; 8，触发器​ 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。 语法结构 12345CREATE TRIGGER 触发器名称&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名FOR EACH ROW触发器执行的语句块; 例子：创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。 12345678910DELIMITER //CREATE TRIGGER before_insertBEFORE INSERT ON test_triggerFOR EACH ROWBEGININSERT INTO test_trigger_log (t_log)VALUES(&#x27;before_insert&#x27;);END //DELIMITER ; 查看、删除触发器 12345SHOW TRIGGERS\\GSHOW CREATE TRIGGER 触发器名SELECT * FROM information_schema.TRIGGERS;DROP TRIGGER IF EXISTS 触发器名称;","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MySql初级查漏补缺","slug":"MySql初级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E5%88%9D%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"}]},{"title":"SparseArray","slug":"SparseArray","date":"2023-06-18T07:29:49.000Z","updated":"2023-07-08T09:17:29.901Z","comments":true,"path":"2023/06/18/SparseArray.html","link":"","permalink":"https://coder-xbai.github.io/2023/06/18/SparseArray.html","excerpt":"","text":"稀疏矩阵的原理及java实现原理 如上图，在一个11X11的二维数组中，其实只有几个有效数字，如果全部存储，会造成空间上的浪费，使用3X3的稀疏数组存储有效值，会节约大量空间。 其中稀疏数组的 row[0][0] ：原始二维数组的行 数；row[0][1]：原始二维数组的列数；row[0][2]：原始二维数组有效值的个数。稀疏数组从第二行开始：row[1][0]代表原始二维数组第一个有效值所在的行索引 ；row[1][0]：原始二维数组第一个有效值所在的列索引；row[1][2]：原始二维数组第一个有效值 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @author: zsf * @date: 2023/6/18 9:56 * @description: */public class SparseArray &#123; public static void main(String[] args) throws IOException &#123;// 创建一个原始的二维数组 11*11// 0表示无棋子 1：黑子 2：白子 int chesssArr1[][] = new int[11][11];// 给有棋子的位置赋值 chesssArr1[1][2] = 1; chesssArr1[2][3] = 2; System.out.println(&quot;原始二维数组：&quot;); for (int[] row : chesssArr1) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; /* * 将二维转换为稀疏数组 * 1 遍历二维数组 得到非0数据的个数 * */ int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125;// 2 创建对应的稀疏数组 int sparseArry[][] = new int[sum + 1][3]; //第二行开始记录值// 3 给稀疏数组第一行赋值 sparseArry[0][0] = 11; sparseArry[0][1] = 11; sparseArry[0][2] = sum;// 4 ,遍历二维数组 ，将非0的数放入稀疏数组 int count = 0; //用于记录第几个非0的数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chesssArr1[i][j] != 0) &#123; count++; //从第二行稀疏数组开始记录非0值所在的行与列 sparseArry[count][0] = i; //行的位置 sparseArry[count][1] = j;//列的位置 sparseArry[count][2] = chesssArr1[i][j];//值 &#125; &#125; &#125;// 5 输出稀疏数组 System.out.println(&quot;得到的稀疏的数组：&quot;); for (int i = 0; i &lt; sparseArry.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, sparseArry[i][0], sparseArry[i][1], sparseArry[i][2]); &#125; System.out.println();// 将稀疏数组还原成原始二维数组// 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]// 2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可. int chesssArr2[][] = new int[sparseArry[0][0]][sparseArry[0][1]]; for (int i = 1; i &lt; sparseArry.length; i++) &#123; chesssArr2[sparseArry[i][0]][sparseArry[i][1]] = sparseArry[i][2]; &#125; System.out.println(&quot;恢复后的二维数组&quot;); for (int[] row : chesssArr2) &#123; for (int data : row) &#123; System.out.printf(&quot;%d\\t&quot;, data); &#125; System.out.println(); &#125; SparseArray a = new SparseArray();// a.save_sparseArray(sparseArry,&quot;src\\\\com\\\\zsf\\\\day01\\\\sparse.txt&quot;); int[][] load_sparseArray = a.load_sparseArray(&quot;src\\\\com\\\\\\\\zsf\\\\day01\\\\sparse.txt&quot;); System.out.println(&quot;读入的稀疏矩阵为~~~~~~~~&quot;); for (int i = 0; i &lt; load_sparseArray.length; i++) &#123; System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, load_sparseArray[i][0], load_sparseArray[i][1], load_sparseArray[i][2]); &#125; &#125;&#125; 稀疏数组的保存与加载1234567891011121314151617181920 public int[][] save_sparseArray(int sparseArry[][], String file_path) throws IOException &#123; // 将稀疏数组保存下来 &quot;./sparse.txt&quot;; String save_dir = file_path; File file = new File(save_dir); if (!file.exists()) &#123; file.createNewFile(); FileWriter fileWriter = new FileWriter(save_dir); for (int i = 0; i &lt; sparseArry.length; i++) &#123; for (int j = 0; j &lt; sparseArry[i].length; j++) &#123; fileWriter.write(sparseArry[i][j] + &quot;\\t&quot;); &#125;// 一行输出完后添加换行符 fileWriter.write(&quot;\\r\\n&quot;); &#125; fileWriter.close(); System.out.println(&quot;保存成功&quot;); &#125;// 加载 return null; &#125; 1234567891011121314151617181920212223 public int[][] load_sparseArray(String file_path) throws IOException &#123; File file = new File(file_path); BufferedReader in = new BufferedReader(new FileReader(file)); String line; int row = 0; String[] tem;// 在使用一次in.lines/readline后，文件指针指向文件末尾，即都是0// long num_row = in.lines().count(); int sparseArry[][] = new int[3][3]; int count = 0;// 1 要确定文件中稀疏数组有多少行 while ((line = in.readLine()) != null) &#123;// line 接收了每一行的 字符 ,即稀疏数组的 行数 tem = line.split(&quot;\\t&quot;); System.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, Integer.parseInt(tem[0]), Integer.parseInt(tem[1]), Integer.parseInt(tem[2])); sparseArry[count][0] = Integer.parseInt(tem[0]); //行的位置 sparseArry[count][1] = Integer.parseInt(tem[1]);//列的位置 sparseArry[count][2] = Integer.parseInt(tem[2]);//值 count++; &#125; return sparseArry; &#125; 实现效果 容易踩坑的点 使用 BufferedReader 的api 时要注意，你只要调用过一次 in.read或in.read()文件指针指向文件末尾，即都是0 时时记住模块化开发，提高程序的复用性","categories":[{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"}],"tags":[{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"}]},{"title":"MongoDB数据库","slug":"MongDB","date":"2023-02-01T02:39:11.000Z","updated":"2023-07-08T09:17:39.830Z","comments":true,"path":"2023/02/01/MongDB.html","link":"","permalink":"https://coder-xbai.github.io/2023/02/01/MongDB.html","excerpt":"","text":"MongoDB数据库是以集合为单位的 use 数据库 不是集合 mongodb插入数据 db.collection.insert({}） 插入数据，id存在就出错 dbcollection.save({}) 插入数据，_id存在就修改，_id不存在就添加 ###修改数据 db.集合名称。update（,,{multi:}) db.collection.update({“name”:”hr”},{“name”:”mnc”}) 更新一条，根据键值对更新 db.collection.update({“name”:”hr”},{$set:{“name”:”mnc”}}） 更新一条 db.collection.update({},$set:{“gender”:0},{multi:true}) muiti参数默认为false时，只更新一条数据，为true时，更新全部数据 ###删除数据库 db.dropDatabase(){ “dropped” : “runoob”, “ok” : 1 }###删除集合 db.collection.drop()###删除数据 -db.collection.remove({“age”:”22”},{justone:true}) justone 默认为false，即删除全部指定条件的数据。为false时，只删除一条数据 条件查询 db.collection.find({“age”:”22”}) 通过某条数据中的片段（键值对）来进行限定查询，这是一个多行查询 db.collection.findOne({“age”:”22”}) 只查询符合条件的一条数据 db.collection.find({“age”:”22”}).pretty() 格式化输出查询结果 ####比较运算符 等于： ： 小于： $lt(less than) 小于等于： $lte(less than equal) 大于： $gt(greater than) 大于等于： $gte(greater than equal) 不等于： $ne 范围： $in db.collection.find({“age”:{$lt:18}}) 查询年龄小于18的所有的数据 db.collection.find({age:{$in:[18,28,38]}}) 查询年龄18，28，38 的数据 db.collection.find（{“age”:”18”,”addr”:”上海”}）多字段查询 逻辑运算符 and :在json中写多个条件即可 $or :值为数组，数组中每个元素为json 123db.test1000.find(&#123;$or:[&#123;age:12&#125;,&#123;&quot;name&quot;:&quot;xiaohong&quot;&#125;]&#125;) # $or:[&#123;键值对&#125;，键值对] $nor: （既不也不） db.collection1.find({$nor:[{name:”xiaomu”},{name:”xiaoli”}]}) 查询姓名不为xiaomu,xiaoli的全部数据 不在范围： $nin:[] 正则表达式db.collection.find({name:/^abc/}) #name 字段中包含abc的所欲数据 12db.test1000.find(&#123;name:&#123;$regex:&quot;hong&quot;&#125;&#125;) #包含hong这个字段的数据 1db.test1000.find(&#123;name:&#123;$regex:&quot;hong$&quot;&#125;&#125;) #以hong结尾的字段的数据 ###分页： db.collection1.find().skip(0).limit(10) ;//查询从0条开始，查询10条，skip()方法默认参数为 0 ，表示跳过的条数 （当数据量大的时候，先skip再limit） ###自定义查询 db.test1000.find({$where:function(){return this.age&gt;18;}}) 查询年龄大于18的数据 ###投影查询 db.collection.find({},_id:0,name:1) 参数为1表示显示，参数为0为不显示，如果不显示字段，要明确设置为0 ###排序 db.collection1.find().sort({age:1});//按照年龄升序排序，为-1的话表示降序排序 ###存在 db.c2.find({hight:{$exists:1}})；//查询存在hight字段的数据 ###查看数据总条数 db.collection1.count();//统计集合collection1中的数据数量 db.collection1.find({条件}).count();//统计集合collection1中的数据数量 #消除重复 db.collection.distinct({}) ##数据备份与恢复 备份：mongodump -h dbhost -d dbname -o dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test -o：需要备份的数据存放的位置，例如：d:\\data (如果没有则自动创建) 恢复：mongorestore -h dbhost -d dbname -directoryperdb dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，如：test，此名称也可以和备份的时候不一样 -directoryperdb ：备份数据所在的位置，例如：d:\\data注意：恢复时要在退出mongo命令行状态下执行 ###导入和导出 导出：mongoexport -h dbhost -d dbname -c collectionName -o output -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 -o：指明要导出的文件路径加文件名，文件名可以是txt、word、excel等多种文件格式 -导入：mongoimport -h dbhost -d dbname -c collectionname 文件的地址路径 -h：数据库地址 -d：指明使用的库 -c：指明要导出的集合 注意：导入时要在退出mongo命令行状态下执行，导入导出与数据备份和恢复相似 mongodb聚合命令12345678db.collection.aggregate(&#123; $group:&#123; _id:&quot;$gender&quot;, #_id:(可以是多个参数，后续调用时，用.对象名的方法) counter:&#123;$sum:1&#125; &#125;&#125;) 其中还有 $match(匹配到适合条件的数据) $project：(投影显示)修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $min,max,sun,avg,first,last 等 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。（有一个保留空值和空列表的参数：perserve….） $sort:将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 爬虫数据去重（增量式爬虫） 使用数据可建立关键字段的唯一索引进行去重 联合索引（通过多个字段来确定数据的唯一性） url地址去重 url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况 url存在redis中 拿到url地址，判断url在redis的集合中是否存在 存在：说明url已经被请求过，不再请求 不存在：url没有被请求过，请求，把该url存入redis的集合中 ####布隆过滤器 （redis） 使用加密算法加密url地址，得到多个值， 往对应值的位置把结果设置为1 新来一个url地址，一样通过加密算法生成多个值 如果对应位置的值全为1，说明这个url地址已经请求过 否则没有请求过，请求后，就把对应位置的值设置为1 根据数据本身去重 选择特定的字段，使用加密算法（MD5，sha1）将字段进行加密，生成字符串，存入redis的集合中 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入","categories":[{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}],"categories":[{"name":"test","slug":"test","permalink":"https://coder-xbai.github.io/categories/test/"},{"name":"若依框架学习","slug":"若依框架学习","permalink":"https://coder-xbai.github.io/categories/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"},{"name":"找工作","slug":"找工作","permalink":"https://coder-xbai.github.io/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"},{"name":"database","slug":"database","permalink":"https://coder-xbai.github.io/categories/database/"},{"name":"JAVA","slug":"JAVA","permalink":"https://coder-xbai.github.io/categories/JAVA/"},{"name":"data_Structures& algorithm","slug":"data-Structures-algorithm","permalink":"https://coder-xbai.github.io/categories/data-Structures-algorithm/"}],"tags":[{"name":"ruoyi_1","slug":"ruoyi-1","permalink":"https://coder-xbai.github.io/tags/ruoyi-1/"},{"name":"job","slug":"job","permalink":"https://coder-xbai.github.io/tags/job/"},{"name":"redis面试常问","slug":"redis面试常问","permalink":"https://coder-xbai.github.io/tags/redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE/"},{"name":"Spring框架","slug":"Spring框架","permalink":"https://coder-xbai.github.io/tags/Spring%E6%A1%86%E6%9E%B6/"},{"name":"MySql中高级查漏补缺","slug":"MySql中高级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E4%B8%AD%E9%AB%98%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"MySql初级查漏补缺","slug":"MySql初级查漏补缺","permalink":"https://coder-xbai.github.io/tags/MySql%E5%88%9D%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"SparseArray","slug":"SparseArray","permalink":"https://coder-xbai.github.io/tags/SparseArray/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://coder-xbai.github.io/tags/MongoDB/"}]}