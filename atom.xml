<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://coder-xbai.github.io/atom.xml" rel="self"/>
  
  <link href="https://coder-xbai.github.io/"/>
  <updated>2023-06-27T13:53:47.096Z</updated>
  <id>https://coder-xbai.github.io/</id>
  
  <author>
    <name>coder-xbai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql_1</title>
    <link href="https://coder-xbai.github.io/2023/06/27/mysql-1.html"/>
    <id>https://coder-xbai.github.io/2023/06/27/mysql-1.html</id>
    <published>2023-06-27T02:25:15.000Z</published>
    <updated>2023-06-27T13:53:47.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySql初级查漏补缺"><a href="#MySql初级查漏补缺" class="headerlink" title="MySql初级查漏补缺"></a>MySql初级查漏补缺</h2><h3 id="1，支持的json类型"><a href="#1，支持的json类型" class="headerlink" title="1，支持的json类型"></a>1，支持的json类型</h3><p>​    从mysql5.7开始支持，到8.x版本时JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使用更方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE  DATABASE IF NOT EXISTS test01_office CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line"></span><br><span class="line">USE test01_office</span><br><span class="line"></span><br><span class="line">CREATE TABLE test_json(</span><br><span class="line">js json</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- json 类型 &#x27;&#123;&quot;KEY1&quot;:&quot;value1&quot;,&quot;KEY2&quot;:&quot;value2&quot; &#125;&#x27;</span><br><span class="line">INSERT INTO test_json (js)</span><br><span class="line">VALUES (</span><br><span class="line">&#x27;&#123;&quot;KEY&quot;:&quot;value&quot;,&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,</span><br><span class="line">&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM test_json;</span><br></pre></td></tr></table></figure><h3 id="2，使用时间类型选择"><a href="#2，使用时间类型选择" class="headerlink" title="2，使用时间类型选择"></a>2，使用时间类型选择</h3><p>​    在多数开发过程中，都是选择 DATETIME 类型，包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。 但是如果是记录注册时间或商品发布时间等。使用_TIMESTAMP(时间戳)更方便计算。</p><h3 id="3，主键自增一个小知识-—自增变量的持久化"><a href="#3，主键自增一个小知识-—自增变量的持久化" class="headerlink" title="3，主键自增一个小知识 —自增变量的持久化"></a>3，主键自增一个小知识 —自增变量的持久化</h3><p>​    在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。</p><p><img src="/images/pic/MySQL_1.jpg" alt="img"></p><p>​    从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。 删除id为5的记录，结果如下：</p><p><img src="/images/pic/MySQL_2.jpg" alt="img"></p><p>​    从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p><p>​    在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：</p><p><img src="/images/pic/MySQL_2.jpg" alt="img"></p><pre><code>从结果可以看出，自增变量已经持久化了。</code></pre><p>​    MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p><h3 id="4，存储过程"><a href="#4，存储过程" class="headerlink" title="4，存储过程"></a>4，存储过程</h3><h4 id="创建存储过程格式"><a href="#创建存储过程格式" class="headerlink" title="创建存储过程格式"></a>创建存储过程格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">存储过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>​    说明：INOUT ：当前参数既可以为输入参数，也可以为输出参数。</p><p>​    类似于Java中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT COUNT(*) INTO num FROM fruits</span><br><span class="line">WHERE s_id = sid;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="调用存储过程及查看返回结果"><a href="#调用存储过程及查看返回结果" class="headerlink" title="调用存储过程及查看返回结果"></a>调用存储过程及查看返回结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CALL CountProc (101, @num);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">-- 查看返回结果</span><br><span class="line">mysql&gt; SELECT @num;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5，变量、流程控制与游标的重要知识"><a href="#5，变量、流程控制与游标的重要知识" class="headerlink" title="5，变量、流程控制与游标的重要知识"></a>5，变量、流程控制与游标的重要知识</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>​    系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为 会话用户变量 和 局部变量 。</p><p>​    会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。<br>​    局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量 [FROM 等子句];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看用户变量的值 （查看、比较、运算等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT @用户变量</span><br><span class="line">SELECT @a;</span><br><span class="line">SELECT @num := COUNT(*) FROM employees;</span><br><span class="line">SELECT @num;</span><br><span class="line">SELECT AVG(salary) INTO @avgsalary FROM employees;</span><br><span class="line">SELECT @avgsalary;</span><br><span class="line">SELECT @big; #查看某个未声明的变量时，将得到NULL值</span><br></pre></td></tr></table></figure><p>局部变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL</span><br><span class="line">DECLARE myparam INT DEFAULT 100;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6，流程控制"><a href="#6，流程控制" class="headerlink" title="6，流程控制"></a>6，流程控制</h3><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF 表达式1 THEN 操作1</span><br><span class="line">[ELSEIF 表达式2 THEN 操作2]……</span><br><span class="line">[ELSE 操作N]</span><br><span class="line">END IF</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)</span><br><span class="line">SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year</span><br><span class="line">FROM employees WHERE employee_id = emp_id;</span><br><span class="line">IF emp_salary &lt; 8000 AND hire_year &gt; 5</span><br><span class="line">THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;</span><br><span class="line">END IF;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支结构之-CASE"><a href="#分支结构之-CASE" class="headerlink" title="分支结构之 CASE"></a>分支结构之 CASE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line">CASE 表达式</span><br><span class="line">WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)</span><br><span class="line">WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure><p>例3：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE emp_sal DOUBLE;</span><br><span class="line">DECLARE bonus DECIMAL(3,2);</span><br><span class="line">SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;</span><br><span class="line">CASE</span><br><span class="line">WHEN emp_sal&lt;9000</span><br><span class="line">THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;</span><br><span class="line">WHEN emp_sal&lt;10000 AND bonus IS NULL</span><br><span class="line">THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;</span><br><span class="line">ELSE</span><br><span class="line">UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;</span><br><span class="line">END CASE;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h4 id="循环结构之LOOP"><a href="#循环结构之LOOP" class="headerlink" title="循环结构之LOOP"></a>循环结构之LOOP</h4><p>使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE id INT DEFAULT 0;</span><br><span class="line">add_loop:LOOP</span><br><span class="line">SET id = id +1;</span><br><span class="line">IF id &gt;= 10 THEN LEAVE add_loop;</span><br><span class="line">END IF;</span><br><span class="line">END LOOP add_loop;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="循环结构之WHILE和REPEAT"><a href="#循环结构之WHILE和REPEAT" class="headerlink" title="循环结构之WHILE和REPEAT"></a>循环结构之WHILE和REPEAT</h4><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p><p>例子：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE update_salary_while(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE avg_sal DOUBLE ;</span><br><span class="line">DECLARE while_count INT DEFAULT 0;</span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">WHILE avg_sal &gt; 5000 DO</span><br><span class="line">UPDATE employees SET salary = salary * 0.9;</span><br><span class="line">SET while_count = while_count + 1;</span><br><span class="line">SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">END WHILE;</span><br><span class="line">SET num = while_count;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE test_repeat()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">REPEAT</span><br><span class="line">SET i = i + 1;</span><br><span class="line">UNTIL i &gt;= 10</span><br><span class="line">END REPEAT;</span><br><span class="line">SELECT i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>跳转语句之LEAVE语句  (类似于 java中的break)，跳转语句之ITERATE语句（类似于 java中的continue）  具体解释省略</p><h3 id="7，游标"><a href="#7，游标" class="headerlink" title="7，游标"></a>7，游标</h3><p>​    定义：在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。 </p><p>游标的使用过程：</p><p>第一步，声明游标()；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cur_emp CURSOR FOR</span><br></pre></td></tr></table></figure><p>第二步，打开游标(OPEN cursor_name)；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure><p>第三步使用游标（从游标中取得数据）()；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure><p>第四步，关闭游标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure><p>​    例子：创建存储过程“get_count_by_limit_total_salary()”，声明IN参limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT</span><br><span class="line">total_count INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资</span><br><span class="line">DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line">DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">#打开游标</span><br><span class="line">OPEN emp_cursor;</span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line">FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">SET emp_count = emp_count + 1;</span><br><span class="line">UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">END REPEAT;</span><br><span class="line">SET total_count = emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line">CLOSE emp_cursor;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8，触发器"><a href="#8，触发器" class="headerlink" title="8，触发器"></a>8，触发器</h3><p>​    触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 自动 激发触发器执行相应的操作。当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><p>语法结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称</span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名</span><br><span class="line">FOR EACH ROW</span><br><span class="line">触发器执行的语句块;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子：创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE TRIGGER before_insert</span><br><span class="line">BEFORE INSERT ON test_trigger</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO test_trigger_log (t_log)</span><br><span class="line">VALUES(&#x27;before_insert&#x27;);</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看、删除触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS\G</span><br><span class="line">SHOW CREATE TRIGGER 触发器名</span><br><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br><span class="line">DROP TRIGGER IF EXISTS 触发器名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySql初级查漏补缺&quot;&gt;&lt;a href=&quot;#MySql初级查漏补缺&quot; class=&quot;headerlink&quot; title=&quot;MySql初级查漏补缺&quot;&gt;&lt;/a&gt;MySql初级查漏补缺&lt;/h2&gt;&lt;h3 id=&quot;1，支持的json类型&quot;&gt;&lt;a href=&quot;#1，支持的j</summary>
      
    
    
    
    <category term="database" scheme="https://coder-xbai.github.io/categories/database/"/>
    
    
    <category term="MySql初级查漏补缺" scheme="https://coder-xbai.github.io/tags/MySql%E5%88%9D%E7%BA%A7%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>SparseArray</title>
    <link href="https://coder-xbai.github.io/2023/06/18/SparseArray.html"/>
    <id>https://coder-xbai.github.io/2023/06/18/SparseArray.html</id>
    <published>2023-06-18T07:29:49.000Z</published>
    <updated>2023-06-27T02:59:48.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="稀疏矩阵的原理及java实现"><a href="#稀疏矩阵的原理及java实现" class="headerlink" title="稀疏矩阵的原理及java实现"></a>稀疏矩阵的原理及java实现</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/pic/SparseArray_1.jpg" alt="img"></p><p>如上图，在一个11X11的二维数组中，其实只有几个有效数字，如果全部存储，会造成空间上的浪费，使用3X3的稀疏数组存储有效值，会节约大量空间。</p><p>其中稀疏数组的 row[0][0] ：原始二维数组的行 数；row[0][1]：原始二维数组的列数；row[0][2]：原始二维数组有效值的个数。稀疏数组从第二行开始：row[1][0]代表原始二维数组第一个有效值所在的行索引 ；row[1][0]：原始二维数组第一个有效值所在的列索引；row[1][2]：原始二维数组第一个有效值</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zsf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/6/18 9:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//      创建一个原始的二维数组  11*11</span></span><br><span class="line"><span class="comment">//        0表示无棋子 1：黑子 2：白子</span></span><br><span class="line">        <span class="type">int</span> chesssArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        给有棋子的位置赋值</span></span><br><span class="line">        chesssArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chesssArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始二维数组：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chesssArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将二维转换为稀疏数组</span></span><br><span class="line"><span class="comment">         * 1 遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chesssArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2 创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArry[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];  <span class="comment">//第二行开始记录值</span></span><br><span class="line"><span class="comment">//        3 给稀疏数组第一行赋值</span></span><br><span class="line">        sparseArry[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArry[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArry[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"><span class="comment">//        4 ,遍历二维数组 ，将非0的数放入稀疏数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//用于记录第几个非0的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chesssArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;  <span class="comment">//从第二行稀疏数组开始记录非0值所在的行与列</span></span><br><span class="line">                    sparseArry[count][<span class="number">0</span>] = i;  <span class="comment">//行的位置</span></span><br><span class="line">                    sparseArry[count][<span class="number">1</span>] = j;<span class="comment">//列的位置</span></span><br><span class="line">                    sparseArry[count][<span class="number">2</span>] = chesssArr1[i][j];<span class="comment">//值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        5 输出稀疏数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏的数组：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArry.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArry[i][<span class="number">0</span>], sparseArry[i][<span class="number">1</span>], sparseArry[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        将稀疏数组还原成原始二维数组</span></span><br><span class="line"><span class="comment">//        1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2=int[11][11]</span></span><br><span class="line"><span class="comment">//        2.在读取稀疏数组后几行的数据，并赋给原始的二维数组即可.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> chesssArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArry[<span class="number">0</span>][<span class="number">0</span>]][sparseArry[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArry.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            chesssArr2[sparseArry[i][<span class="number">0</span>]][sparseArry[i][<span class="number">1</span>]] = sparseArry[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chesssArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SparseArray</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparseArray</span>();</span><br><span class="line"><span class="comment">//        a.save_sparseArray(sparseArry,&quot;src\\com\\zsf\\day01\\sparse.txt&quot;);</span></span><br><span class="line">        <span class="type">int</span>[][] load_sparseArray = a.load_sparseArray(<span class="string">&quot;src\\com\\\\zsf\\day01\\sparse.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;读入的稀疏矩阵为~~~~~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; load_sparseArray.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, load_sparseArray[i][<span class="number">0</span>], load_sparseArray[i][<span class="number">1</span>], load_sparseArray[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="稀疏数组的保存与加载"><a href="#稀疏数组的保存与加载" class="headerlink" title="稀疏数组的保存与加载"></a>稀疏数组的保存与加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] save_sparseArray(<span class="type">int</span> sparseArry[][], String file_path) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//    将稀疏数组保存下来 &quot;./sparse.txt&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">save_dir</span> <span class="operator">=</span> file_path;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(save_dir);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(save_dir);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArry.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sparseArry[i].length; j++) &#123;</span><br><span class="line">                    fileWriter.write(sparseArry[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                    一行输出完后添加换行符</span></span><br><span class="line">                fileWriter.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            fileWriter.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        加载</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] load_sparseArray(String file_path) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file_path);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String[] tem;</span><br><span class="line"><span class="comment">//            在使用一次in.lines/readline后，文件指针指向文件末尾，即都是0</span></span><br><span class="line"><span class="comment">//        long num_row = in.lines().count();</span></span><br><span class="line">        <span class="type">int</span> sparseArry[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//       1 要确定文件中稀疏数组有多少行</span></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//          line  接收了每一行的 字符 ,即稀疏数组的 行数</span></span><br><span class="line">            tem = line.split(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, Integer.parseInt(tem[<span class="number">0</span>]), Integer.parseInt(tem[<span class="number">1</span>]), Integer.parseInt(tem[<span class="number">2</span>]));</span><br><span class="line">            sparseArry[count][<span class="number">0</span>] = Integer.parseInt(tem[<span class="number">0</span>]);  <span class="comment">//行的位置</span></span><br><span class="line">            sparseArry[count][<span class="number">1</span>] = Integer.parseInt(tem[<span class="number">1</span>]);<span class="comment">//列的位置</span></span><br><span class="line">            sparseArry[count][<span class="number">2</span>] = Integer.parseInt(tem[<span class="number">2</span>]);<span class="comment">//值</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sparseArry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/images/pic/SparseArray_2.jpg" alt="img"></p><h3 id="容易踩坑的点"><a href="#容易踩坑的点" class="headerlink" title="容易踩坑的点"></a>容易踩坑的点</h3><ol><li>使用  BufferedReader 的api 时要注意，你只要调用过一次 in.read或in.read()文件指针指向文件末尾，即都是0</li><li>时时记住模块化开发，提高程序的复用性</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;稀疏矩阵的原理及java实现&quot;&gt;&lt;a href=&quot;#稀疏矩阵的原理及java实现&quot; class=&quot;headerlink&quot; title=&quot;稀疏矩阵的原理及java实现&quot;&gt;&lt;/a&gt;稀疏矩阵的原理及java实现&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot;</summary>
      
    
    
    
    <category term="data_Structures&amp; algorithm" scheme="https://coder-xbai.github.io/categories/data-Structures-algorithm/"/>
    
    
    <category term="SparseArray" scheme="https://coder-xbai.github.io/tags/SparseArray/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="https://coder-xbai.github.io/2023/02/01/MongDB.html"/>
    <id>https://coder-xbai.github.io/2023/02/01/MongDB.html</id>
    <published>2023-02-01T02:39:11.000Z</published>
    <updated>2023-06-16T05:49:51.299Z</updated>
    
    <content type="html"><![CDATA[<p> MongoDB数据库是以集合为单位的</p><ul><li>use 数据库 不是集合<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h3 id="mongodb插入数据"><a href="#mongodb插入数据" class="headerlink" title="mongodb插入数据"></a>mongodb插入数据</h3><ul><li>db.collection.insert({}） 插入数据，id存在就出错</li><li>dbcollection.save({}) 插入数据，_id存在就修改，_id不存在就添加</li></ul><p>###修改数据 db.集合名称。update（<query>,<query>,{multi:<boolean>})</p><ul><li>db.collection.update({“name”:”hr”},{“name”:”mnc”})  更新一条，根据键值对更新</li></ul><ul><li>db.collection.update({“name”:”hr”},{$set:{“name”:”mnc”}}） 更新一条</li></ul><ul><li>db.collection.update({},$set:{“gender”:0},{multi:true}) muiti参数默认为false时，只更新一条数据，为true时，更新全部数据</li></ul><p>###删除数据库</p><ul><li> db.dropDatabase()<br>{ “dropped” : “runoob”, “ok” : 1 }<br>###删除集合</li><li>db.collection.drop()<br>###删除数据</li></ul><p>-db.collection.remove({“age”:”22”},{justone:true}) justone 默认为false，即删除全部指定条件的数据。为false时，只删除一条数据</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><ul><li><p>db.collection.find({“age”:”22”}) 通过某条数据中的片段（键值对）来进行限定查询，这是一个多行查询</p></li><li><p>db.collection.findOne({“age”:”22”}) 只查询符合条件的一条数据</p></li></ul><ul><li> db.collection.find({“age”:”22”}).pretty() 格式化输出查询结果</li></ul><p>####比较运算符</p><ul><li><p>等于：    ：</p></li><li><p>小于：    $lt(less than)</p></li><li><p>小于等于： $lte(less than equal)</p></li><li><p>大于：    $gt(greater than)</p></li><li><p>大于等于： $gte(greater than equal)</p></li><li><p>不等于：   $ne</p></li><li><p>范围：     $in</p></li><li><p>db.collection.find({“age”:{$lt:18}}) 查询年龄小于18的所有的数据</p></li><li><p>db.collection.find({age:{$in:[18,28,38]}})   查询年龄18，28，38 的数据</p></li><li><p>db.collection.find（{“age”:”18”,”addr”:”上海”}）多字段查询</p></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>and :在json中写多个条件即可</li></ul><ul><li>$or :值为数组，数组中每个元素为json</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.test1000.find(&#123;$or:[&#123;age:12&#125;,&#123;&quot;name&quot;:&quot;xiaohong&quot;&#125;]&#125;)</span><br><span class="line"></span><br><span class="line">   # $or:[&#123;键值对&#125;，键值对] </span><br></pre></td></tr></table></figure><ul><li><p>$nor: （既不也不）</p></li><li><p>db.collection1.find({$nor:[{name:”xiaomu”},{name:”xiaoli”}]}) 查询姓名不为xiaomu,xiaoli的全部数据</p></li><li><p>不在范围：     $nin:[]</p></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>db.collection.find({name:/^abc/})  #name 字段中包含abc的所欲数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.test1000.find(&#123;name:&#123;$regex:&quot;hong&quot;&#125;&#125;) </span><br><span class="line"> #包含hong这个字段的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test1000.find(&#123;name:&#123;$regex:&quot;hong$&quot;&#125;&#125;)  #以hong结尾的字段的数据 </span><br></pre></td></tr></table></figure><p>###分页：</p><ul><li>db.collection1.find().skip(0).limit(10)    ;//查询从0条开始，查询10条，skip()方法默认参数为 0 ，表示跳过的条数 （当数据量大的时候，先skip再limit）</li></ul><p>###自定义查询</p><ul><li> db.test1000.find({$where:function(){return this.age&gt;18;}})  查询年龄大于18的数据</li></ul><p>###投影查询 </p><ul><li>db.collection.find({},_id:0,name:1) 参数为1表示显示，参数为0为不显示，如果不显示字段，要明确设置为0</li></ul><p>###排序</p><ul><li>db.collection1.find().sort({age:1});//按照年龄升序排序，为-1的话表示降序排序</li></ul><p>###存在</p><ul><li>db.c2.find({hight:{$exists:1}})；//查询存在hight字段的数据</li></ul><p>###查看数据总条数</p><ul><li>db.collection1.count();//统计集合collection1中的数据数量</li><li>db.collection1.find({条件}).count();//统计集合collection1中的数据数量</li></ul><p>#消除重复</p><ul><li>db.collection.distinct({})</li></ul><p>##数据备份与恢复</p><ol><li>备份：mongodump -h dbhost -d dbname -o dbdirectory</li></ol><ol start="2"><li>-h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</li><li>-d：需要备份的数据库实例，如：test</li><li>-o：需要备份的数据存放的位置，例如：d:\data (如果没有则自动创建)</li></ol><ul><li>恢复：mongorestore -h dbhost -d dbname -directoryperdb dbdirectory</li></ul><ol start="5"><li>-h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</li></ol><ol start="6"><li>-d：需要备份的数据库实例，如：test，此名称也可以和备份的时候不一样</li></ol><ol start="7"><li>-directoryperdb ：备份数据所在的位置，例如：d:\data<br>注意：恢复时要在退出mongo命令行状态下执行</li></ol><p>###导入和导出</p><ul><li>导出：mongoexport -h dbhost -d dbname -c collectionName -o output</li></ul><ol><li>-h：数据库地址</li><li>-d：指明使用的库</li><li>-c：指明要导出的集合</li><li>-o：指明要导出的文件路径加文件名，文件名可以是txt、word、excel等多种文件格式</li></ol><p>-导入：mongoimport -h dbhost -d dbname -c collectionname 文件的地址路径</p><ol><li>-h：数据库地址</li><li>-d：指明使用的库</li><li>-c：指明要导出的集合</li><li>注意：导入时要在退出mongo命令行状态下执行，导入导出与数据备份和恢复相似</li></ol><h1 id="mongodb聚合命令"><a href="#mongodb聚合命令" class="headerlink" title="mongodb聚合命令"></a>mongodb聚合命令</h1><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate(</span><br><span class="line">&#123; $group:&#123;</span><br><span class="line"></span><br><span class="line">_id:&quot;$gender&quot;,        #_id:(可以是多个参数，后续调用时，用.对象名的方法)</span><br><span class="line">counter:&#123;$sum:1&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中还有</p><ul><li>$match(匹配到适合条件的数据)</li><li>$project：(投影显示)修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$min,max,sun,avg,first,last 等</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。（有一个保留空值和空列表的参数：perserve….）</li><li>$sort:将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><h3 id="爬虫数据去重（增量式爬虫）"><a href="#爬虫数据去重（增量式爬虫）" class="headerlink" title="爬虫数据去重（增量式爬虫）"></a>爬虫数据去重（增量式爬虫）</h3><ul><li>使用数据可建立关键字段的唯一索引进行去重</li><li>联合索引（通过多个字段来确定数据的唯一性）</li></ul><ul><li>url地址去重 <ul><li>url地址对应的数据不会变的情况，url地址能够唯一判别一条数据的情况</li><li>url存在redis中</li></ul><ol><li>拿到url地址，判断url在redis的集合中是否存在</li><li>存在：说明url已经被请求过，不再请求</li><li>不存在：url没有被请求过，请求，把该url存入redis的集合中 </li></ol></li></ul><p>####布隆过滤器 （redis）</p><ul><li>使用加密算法加密url地址，得到多个值，</li><li>往对应值的位置把结果设置为1</li><li>新来一个url地址，一样通过加密算法生成多个值</li><li>如果对应位置的值全为1，说明这个url地址已经请求过</li><li>否则没有请求过，请求后，就把对应位置的值设置为1</li></ul><h4 id="根据数据本身去重"><a href="#根据数据本身去重" class="headerlink" title="根据数据本身去重"></a>根据数据本身去重</h4><ul><li>选择特定的字段，使用加密算法（MD5，sha1）将字段进行加密，生成字符串，存入redis的集合中</li><li> 后续新来一条数据，同样的方法进行加密，如果得到的字符串在redis中存在，说明数据存在，对数据进行更新，否则说明数据不存在，直接插入</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; MongoDB数据库是以集合为单位的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;use 数据库 不是集合&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;mongodb插入数据&quot;&gt;</summary>
      
    
    
    
    <category term="database" scheme="https://coder-xbai.github.io/categories/database/"/>
    
    
    <category term="MongoDB" scheme="https://coder-xbai.github.io/tags/MongoDB/"/>
    
  </entry>
  
</feed>
